-- CONNECT TO interlex_test USER "interlex-admin";

CREATE TABLE export_rules(
       -- id serial not null,
       id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- preferred for 10+
       perspective integer NOT NULL references perspectives (id),
       rule text NOT NULL  -- FIXME TODO how to encode these? can we avoid parsing?
);

CREATE TABLE uris(
       -- TODO may need a holding area for unmapped uris for certain workflows
       -- OR we may need to return the file with suggested mappings
       perspective integer NOT NULL references perspectives (id),
       uri_path text NOT NULL,
       PRIMARY KEY (perspective, uri_path), -- groups may only map a uri path to a single ilx_id
       CHECK ((uri_path ~* '^\S+') AND (uri_path ~* '\S+$')),
       CHECK (('http://interlex.org/uris/' || uri_path)::uri is not null) -- make sure it will parse
       -- uri_full uri not null,  -- yes or no?
       -- branch_private default false  -- TOOD this needs to be managed elsewhere?
       -- terminal -> branch changes? one way to cope is always resolve /branch/ -> branch
       -- but then we have to know which are branches...
       -- unique on user_id ilx_id as discussed in the spec or what?
       -- FIXME un__uris does not account for provisional paths ...
);

CREATE TABLE uri_mapping(
       -- FIXME TODO same issues with history that we have with existing iris
       -- likely the proposed solution using this table to ensure consistency
       -- at all times while using triples to track history makes the most sense
       -- we will likely have to grant update on uri_mapping and existing_iris
       -- but we may do that with a specific user that is separate from interlex-user
       perspective integer NOT NULL references perspectives (id),
       uri_path text NOT NULL,
       ilx_prefix text NOT NULL,
       ilx_id text NOT NULL, -- TODO how to enforce the 'no changing the ilx_id' block delete?
       PRIMARY KEY (perspective, uri_path), -- groups may only map a uri path to a single ilx_id
       CHECK ((uri_path ~* '^\S+') AND (uri_path ~* '\S+$')),
       -- UNIQUE (group_id, ilx_prefix, ilx_id),  -- groups may only map an ilx_id to a single readable XXX this may be true for readables, but in the general case what if I have two separate ontologies where i want to use the same local conventions but have different uris? I think the answer is that for that you should use a different perspective? but that does seem like overkill, probably better to warn in cases where multiple uris map to the same value, OR set the unique restriction to be only on /uris/readable/
       FOREIGN KEY (perspective, uri_path) REFERENCES uris (perspective, uri_path),
       FOREIGN KEY (ilx_prefix, ilx_id) REFERENCES interlex_ids (prefix, id) match simple
);

CREATE UNIQUE INDEX un__uri_mapping__readable_unique
       ON uri_mapping (perspective, ilx_prefix, ilx_id)
       WHERE uri_path like 'readable/%';

-- CREATE TRIGGER uris_static ON uris BEFORE UPDATE OR DELETE -- dealt with via no update or delete permissions for interlex-user

/* -- no longer needed because uris and uri_mapping now handled the unmapped cases transparently
CREATE TABLE uri_branches(
       -- uris that may or may not be resolvable but that users want to make private or other things
       -- things can only start private, they cannot be unprivated

       -- the logic for this is a bit tricky
       -- because things u
       group_id integer NOT NULL,
       branch_path text NOT NULL,
       public boolean NOT NULL,
       CONSTRAINT fk__uri_branches__group_id__groups FOREIGN key (group_id) REFERENCES groups (id) match simple
);

CREATE FUNCTION branch_no_hide() returns trigger AS $branch_no_hide$
       BEGIN
           IF NEW.public THEN
              RAISE exception 'Branch % is already public, you cannot make it private!', NEW.branch_path;
           END IF;
           RETURN NULL;
       END;
$branch_no_hide$ language plpgsql;

CREATE TRIGGER branch_no_hide before update ON uri_branches FOR each row execute procedure branch_no_hide();
*/

CREATE TABLE curies(
       -- TODO hook this into the qualifiers and the identities section
       -- computing curied representations can be quite expensive
       -- TODO this needs history of some kind for versions, qualify the curies
       -- TODO this needs a major rework, enforcing restrictions requires some thinking
       -- because using qualifiers makes it hard to ensure uniqueness, maybe a BEFORE INSERT trigger?

       -- we do actually have a use case for this, which is 'what did this curie mean on this date'
       -- we would like to have a record of every mapping in the event that the context is lost
       id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
       perspective integer references perspectives (id), -- if the user has not set curies fail over to default user
       local_conventions_identity bytea references identities (identity), -- XXX note that this tables is not fully normalized, we may or may not want to do this because exact curies blocks may be reused across multiple files so a serialization entity to curies section id, or similar in the future, for now this table will do what we need even if we have 100 version of 1000 ontologies probably ... and it is a quick refactor later if needed
       -- XXX further, this should probably technically be serialization_identity_or_curies_metadata_data_identity or something like that
       -- maybe source_identity if it came from something that was never serialized
       CHECK ((perspective IS NOT NULL AND local_conventions_identity IS     NULL) OR
              (perspective IS     NULL AND local_conventions_identity IS NOT NULL)),
       curie_prefix text NOT NULL CHECK (curie_prefix NOT LIKE '%:%'),  -- is case sensitive, TODO validate against the w3c/ietf spec
       iri_namespace uri NOT NULL,
       CHECK ((curie_prefix ~* '^\S+') AND (curie_prefix ~* '\S+$') OR curie_prefix = ''), -- XXX have to allow empty prefix even though we normally want to band it
       -- TODO what uniqueness constraints are we going to impose here?
       -- CHECK (local_conventions_identity IS NOT NULL OR curie_prefix != '') -- XXX can't enforce this here unfortunately
       UNIQUE (perspective, curie_prefix, iri_namespace),
       UNIQUE (local_conventions_identity, curie_prefix, iri_namespace)
);

-- CREATE MATERIALIZED VIEW current_curies AS
--        SELECT t.o_lit, t.p FROM triples AS t JOIN triple_qualifiers AS tq JOIN current_qualifiers AS cq
--        ON cq.qualifier_id on tq.triple_id

CREATE TABLE ontologies(
       -- internal complement to the names table
       -- TODO this is woefully incomplete
       perspective integer references perspectives (id),
       ont_path text, -- we call these reference names elsewhere, XXX however they are sandboxed in /ontologies/uris/ NOT /ontologies/
       PRIMARY KEY (perspective, ont_path),
       CHECK ((ont_path ~* '^\S+') AND (ont_path ~* '\S+$')),
       spec_head_identity bytea, -- point to the identity that contains the latest head info -- TODO trigger to prevent renull after first insert, we don't need to e.g. start from the null identity because we can check all identities that include the type triple identity where there is no identity relation to a previous version
       -- identity relations should be able to hold the previous version of relation i think ?
       spec uri unique not null, -- the spec will be in the triples table and they will include the list of terms
       CHECK (uri_host(spec) = reference_host()), -- AND position('/ontologies/uris' || ont_path || '/spec' in uri_path(spec)) is not null), -- now in trigger where we can check groupname
       iri uri -- in the event that it is different
);

CREATE OR REPLACE FUNCTION ontology_pers_spec_check() RETURNS trigger AS $$
DECLARE
pname text;
recons text;
BEGIN
    -- FIXME TODO handle perspective ontologies instead of only default group perspective ontologies
    SELECT p.name INTO pname FROM perspectives AS p WHERE p.id = NEW.perspective AND p.default_group_perspective;
    recons := '/' || pname || '/ontologies/uris' || NEW.ont_path || '/spec';
    IF (pname IS NULL OR recons != uri_path(NEW.spec)) THEN
       RAISE EXCEPTION 'spec uri does not match recons uri % != %', NEW.spec, recons;
    END IF;
    RETURN NEW;
END;
$$ language plpgsql;

CREATE TRIGGER ontology_pers_spec_check BEFORE INSERT ON ontologies FOR EACH ROW execute procedure ontology_pers_spec_check();

CREATE TYPE follow_types AS ENUM (
-- 'import', -- ont -> ont XXX i think this is also a derived concept
-- 'map', -- uri -> ilx XXX i think this is also a derived concept
-- 'use',  ont -> ilx
-- 'is-used', ilx -> ont TODO ontology-in-which-term-is-used-changes is a bit different in meaning

-- term-in-ontology and ontology-has-term are derived otherwise way too much data

'create', -- bulk upload doesn't count as creating terms for prov purposes, it is creating the whole ontology that maps back
'edit',
'curate',
'review',
'follow', -- receive notifications
'bookmark' -- we don't notify for these, like github stars, but preferably not displayed publicly on resource page because used in ontology is a much stronger signal

);

CREATE TYPE follow_target_types AS ENUM (
'entity-not-property', -- any rdf thing that is not by default a predicate or owl property ...
'property', -- these are used in terms like terms are in ontologies
'ontology',
'pull',
'review',
'committee',  -- following commitee votes is useful though votes
'user', -- very much not sure about this one, i think we allow follow but not notify
'org'
);

CREATE TYPE notify_on AS ENUM (
'new', -- new pull request, new term subClassOf, new review request, new committee request
'comment',
'change',
'fork', -- new variant for terms fork for ontologies
'map' -- includes owl:imports, new user uri mapping, new existing id mapping, technically subPropertyOf change
);

CREATE TABLE follows (
       -- TODO we also use this as an inverted(ish) index to simplify automatic follows
       -- TODO see if the auto follows should go somewhere else? probably not, because
       -- what we will do is mask out ones that user's don't want to execute
       user_id integer references users (id),
       follow_target uri, -- FIXME TODO do we put target_type here explicitly beyond what is in triples? i think yes?
       primary key (user_id, follow_target),
       target_type follow_target_types not null,
       follow_type follow_types not null,
       follow_scope uri,  -- initially limited to subClassOf and owl:imports, if null it is not transitive
       notify notify_on,
       CHECK (((target_type != 'user' and target_type != 'org' and follow_type != 'bookmark') or notify is null)) -- block notify in these cases
);

