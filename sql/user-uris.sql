-- CONNECT TO interlex_test USER "interlex-admin";

CREATE TABLE export_rules(
       -- id serial not null,
       id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- preferred for 10+
       group_id integer NOT NULL,  -- less relevant but important for prov
       rule text NOT NULL,  -- FIXME TODO how to encode these? can we avoid parsing?
       CONSTRAINT fk__export_rules__group_id__groups FOREIGN key (group_id) REFERENCES groups (id) match simple
);

CREATE TABLE uris(
       -- TODO may need a holding area for unmapped uris for certain workflows
       -- OR we may need to return the file with suggested mappings
       group_id integer NOT NULL,
       uri_path text NOT NULL,

       -- uri_full uri not null,  -- yes or no?
       -- branch_private default false  -- TOOD this needs to be managed elsewhere?
       -- terminal -> branch changes? one way to cope is always resolve /branch/ -> branch
       -- but then we have to know which are branches...
       -- unique on user_id ilx_id as discussed in the spec or what?
       CONSTRAINT pk__uris PRIMARY KEY (group_id, uri_path), -- groups may only map a uri path to a single ilx_id
       CONSTRAINT fk__uris__group_id__groups FOREIGN key (group_id) REFERENCES groups (id) match simple
       -- FIXME un__uris does not account for provisional paths ...
);

CREATE TABLE uri_mapping(
       -- FIXME TODO same issues with history that we have with existing iris
       -- likely the proposed solution using this table to ensure consistency
       -- at all times while using triples to track history makes the most sense
       -- we will likely have to grant update on uri_mapping and existing_iris
       -- but we may do that with a specific user that is separate from interlex-user
       group_id integer NOT NULL, -- FIXME perspective_id probably
       uri_path text NOT NULL,
       ilx_prefix text NOT NULL,
       ilx_id text NOT NULL, -- TODO how to enforce the 'no changing the ilx_id' block delete?
       PRIMARY KEY (group_id, uri_path), -- groups may only map a uri path to a single ilx_id
       -- UNIQUE (group_id, ilx_prefix, ilx_id),  -- groups may only map an ilx_id to a single readable XXX this may be true for readables, but in the general case what if I have two separate ontologies where i want to use the same local conventions but have different uris? I think the answer is that for that you should use a different perspective? but that does seem like overkill, probably better to warn in cases where multiple uris map to the same value, OR set the unique restriction to be only on /uris/readable/
       FOREIGN KEY (group_id, uri_path) references uris (group_id, uri_path),
       FOREIGN key (ilx_prefix, ilx_id) REFERENCES interlex_ids (prefix, id) match simple
);

CREATE UNIQUE INDEX un__uri_mapping__readable_unique
       ON uri_mapping (group_id, ilx_prefix, ilx_id)
       WHERE uri_path like 'readable/%';

-- CREATE TRIGGER uris_static ON uris BEFORE UPDATE OR DELETE -- dealt with via no update or delete permissions for interlex-user

/* -- no longer needed because uris and uri_mapping now handled the unmapped cases transparently
CREATE TABLE uri_branches(
       -- uris that may or may not be resolvable but that users want to make private or other things
       -- things can only start private, they cannot be unprivated

       -- the logic for this is a bit tricky
       -- because things u
       group_id integer NOT NULL,
       branch_path text NOT NULL,
       public boolean NOT NULL,
       CONSTRAINT fk__uri_branches__group_id__groups FOREIGN key (group_id) REFERENCES groups (id) match simple
);

CREATE FUNCTION branch_no_hide() returns trigger AS $branch_no_hide$
       BEGIN
           IF NEW.public THEN
              RAISE exception 'Branch % is already public, you cannot make it private!', NEW.branch_path;
           END IF;
           RETURN NULL;
       END;
$branch_no_hide$ language plpgsql;

CREATE TRIGGER branch_no_hide before update ON uri_branches FOR each row execute procedure branch_no_hide();
*/

CREATE TABLE curies(
       -- TODO hook this into the qualifiers and the identities section
       -- computing curied representations can be quite expensive
       -- TODO this needs history of some kind for versions, qualify the curies
       -- TODO this needs a major rework, enforcing restrictions requires some thinking
       -- because using qualifiers makes it hard to ensure uniqueness, maybe a BEFORE INSERT trigger?

       -- we do actually have a use case for this, which is 'what did this curie mean on this date'
       -- we would like to have a record of every mapping in the event that the context is lost
       id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
       group_id integer, -- if the user has not set curies fail over to default user
       local_conventions_identity bytea references identities (identity), -- XXX note that this tables is not fully normalized, we may or may not want to do this because exact curies blocks may be reused across multiple files so a serialization entity to curies section id, or similar in the future, for now this table will do what we need even if we have 100 version of 1000 ontologies probably ... and it is a quick refactor later if needed
       -- XXX further, this should probably technically be serialization_identity_or_curies_metadata_data_identity or something like that
       -- maybe source_identity if it came from something that was never serialized
       CHECK ((group_id IS NOT NULL AND local_conventions_identity IS     NULL) OR
              (group_id IS     NULL AND local_conventions_identity IS NOT NULL)),
       curie_prefix text NOT NULL CHECK (curie_prefix NOT LIKE '%:%'),  -- is case sensitive, TODO validate against the w3c/ietf spec
       iri_namespace uri NOT NULL,
       -- TODO what uniqueness constraints are we going to impose here?
       UNIQUE (group_id, curie_prefix, iri_namespace),
       UNIQUE (local_conventions_identity, curie_prefix, iri_namespace),
       CONSTRAINT fk__curies__group_id__group FOREIGN KEY (group_id) REFERENCES groups (id) match simple
);

-- CREATE MATERIALIZED VIEW current_curies AS
--        SELECT t.o_lit, t.p FROM triples AS t JOIN triple_qualifiers AS tq JOIN current_qualifiers AS cq
--        ON cq.qualifier_id on tq.triple_id
