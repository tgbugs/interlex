-- CONNECT TO interlex_test USER "interlex-admin";

CREATE TABLE export_rules(
       -- id serial not null,
       id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- preferred for 10+
       group_id integer NOT NULL,  -- less relevant but important for prov
       rule text NOT NULL,  -- FIXME TODO how to encode these? can we avoid parsing?
       CONSTRAINT fk__export_rules__group_id__groups FOREIGN key (group_id) REFERENCES groups (id) match simple
);

CREATE TABLE uris(
       -- TODO may need a holding area for unmapped uris for certain workflows
       -- OR we may need to return the file with suggested mappings
       group_id integer NOT NULL,
       ilx_prefix char(32) NOT NULL,
       ilx_id char(32) NOT NULL,  -- TODO how to enforce the 'no changing the ilx_id' block delete?
       uri_path text NOT NULL,

       -- uri_full uri not null,  -- yes or no?
       -- branch_private default false  -- TOOD this needs to be managed elsewhere?
       -- terminal -> branch changes? one way to cope is always resolve /branch/ -> branch
       -- but then we have to know which are branches...
       -- unique on user_id ilx_id as discussed in the spec or what?
       CONSTRAINT pk__uris PRIMARY KEY (group_id, uri_path), -- groups may only map a uri path to a single ilx_id
       CONSTRAINT un__uris UNIQUE (group_id, ilx_prefix, ilx_id),  -- groups may only map an ilx_id to a single readable
       -- FIXME un__uris does not account for provisional paths ...
       CONSTRAINT fk__uris__group_id__groups FOREIGN key (group_id) REFERENCES groups (id) match simple,
       CONSTRAINT fk__uris__ilx_prefix_ilx_id__interlex_ids FOREIGN key (ilx_prefix, ilx_id) REFERENCES interlex_ids (prefix, id) match simple
);

-- CREATE TRIGGER uris_static ON uris BEFORE UPDATE OR DELETE -- dealt with via no update or delete permissions for interlex-user

CREATE TABLE uri_branches(
       -- uris that may or may not be resolvable but that users want to make private or other things
       -- things can only start private, they cannot be unprivated
       group_id integer NOT NULL,
       branch_path text NOT NULL,
       public boolean NOT NULL,
       CONSTRAINT fk__uri_branches__group_id__groups FOREIGN key (group_id) REFERENCES groups (id) match simple
);

CREATE FUNCTION branch_no_hide() returns trigger AS $branch_no_hide$
       BEGIN
           IF NEW.public THEN
              RAISE exception 'Branch % is already public, you cannot make it private!', NEW.branch_path;
           END IF;
           RETURN NULL;
       END;
$branch_no_hide$ language plpgsql;

CREATE TRIGGER branch_no_hide before update ON uri_branches FOR each row execute procedure branch_no_hide();

CREATE TABLE curies(
       -- TODO hook this into the qualifiers and the identities section
       -- computing curied representations can be quite expensive
       -- TODO this needs history of some kind for versions, qualify the curies
       -- TODO this needs a major rework, enforcing restrictions requires some thinking
       -- because using qualifiers makes it hard to ensure uniqueness, maybe a BEFORE INSERT trigger?

       -- we do actually have a use case for this, which is 'what did this curie mean on this date'
       -- we would like to have a record of every mapping in the event that the context is lost
       id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
       group_id integer, -- if the user has not set curies fail over to default user
       serialization_identity bytea, -- XXX note that this tables is not fully normalized, we may or may not want to do this because exact curies blocks may be reused across multiple files so a serialization entity to curies section id, or similar in the future, for now this table will do what we need even if we have 100 version of 1000 ontologies probably ... and it is a quick refactor later if needed
       CHECK (group_id IS NOT NULL OR serialization_identity IS NOT NULL),
       curie_prefix varchar(30) NOT NULL CHECK (curie_prefix NOT LIKE '%:%'),  -- is case sensitive, TODO validate against the w3c/ietf spec
       iri_prefix uri NOT NULL,
       -- TODO what uniqueness constraints are we going to impose here?
       CONSTRAINT un__curies__g_c_i UNIQUE (group_id, curie_prefix, iri_prefix),
       CONSTRAINT fk__curies__group_id__group FOREIGN key (group_id) REFERENCES groups (id) match simple
);

-- CREATE MATERIALIZED VIEW current_curies AS
--        SELECT t.o_lit, t.p FROM triples AS t JOIN triple_qualifiers AS tq JOIN current_qualifiers AS cq
--        ON cq.qualifier_id on tq.triple_id
