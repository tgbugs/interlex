-- interlex-admin interlex_test
-- DO
-- $body$
-- BEGIN

CREATE type group_role AS enum ('admin', 'owner', 'contributor', 'curator', 'org', 'pending', 'deactivated', 'deleted', 'banned', 'erased', 'blacklist', 'builtin');
       -- users with lower enum value (ie admin is lowest) have more privs
       -- permission is only granted, if there is no permission then users can only view
       -- can use ALTER TYPE to insert new values into enums if we need them, much safer than doing it as a table

       -- erased banned + hide all triples they have added (we never really erase) and remove from users table
       -- banned everything that we know of associated with this user id shall be blocked (ip?) the way interlex is built this should almost never need to happen, their content is preserved
       -- curator      can only approve edges contributed by others for inclusion in a given group
                       -- distinct from contributor to manage the curated group where no one can add to that directly
       -- contributor  can add triples in a given group and can create new uris (may want to split these?)
       -- ? mapping    can create new uris and mappings ??? not clear we need this role as distinct from contributor
       -- ? ontology   can create new ontologies and ontology uris and named versions ??? not clear if this as distinct from contributor
       -- owner        can do anything in a particular group users are owners of their own user identical groups
       -- admin        can do anything in any group

CREATE TABLE groups(
       -- working table to store information awaiting verification
       id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- preferred for 10+
       groupname varchar(40) UNIQUE NOT NULL,
       CHECK (groupname ~* '[a-zA-Z0-9_-]'),  -- no special chars in group names
       CHECK (groupname !~* 'ilx_.*'),
       CHECK (groupname !~* 'interlex.+'),
       own_role group_role NOT NULL DEFAULT 'pending', -- TODO trigger preventing insert of anyting < pending to enforce data int
       CHECK (own_role > 'admin')
       -- TODO find a way to check that orgs roles >= 'org'

);

CREATE UNIQUE INDEX groups_lower_index ON groups (lower(groupname));

CREATE FUNCTION groupname_length_check() returns trigger AS $groupname_length_check$
       BEGIN
           IF (length(NEW.groupname) < 5) THEN
              RAISE exception '% is too short! InterLex usernames and org names must be at least 5 characters long.', NEW.groupname;
           ELSE
              RETURN NEW;
           END IF;
       END;
$groupname_length_check$ language plpgsql;

CREATE TRIGGER groupname_length_check BEFORE INSERT ON groups FOR each row execute procedure groupname_length_check();
-- alter table groups enable trigger groupname_length_check;

 -- ALTER TABLE groups add CONSTRAINT cc__groups__groupname_len_gt_4 CHECK (length(groupname) > 4);
      -- FIXME have to find another way to enforce this since we want _some_ usernames to be shorter
      -- probably do this in the python
      -- prevent the creation of groups with names len < 5
      -- without administrator

/* -- as long as we use serializable isolation (duh) we don't need this table
CREATE TABLE new_users(
       id integer PRIMARY KEY,
       putative_orcid uri UNIQUE NOT NULL,  -- TODO ask to update on failure? also http://dead.interlex.org/ORCID-SIGNUP-REQUIRED
       -- That orcid does not exist!
       orcid_validated boolean DEFAULT FALSE,
       email_validated boolean DEFAULT FALSE,
       CONSTRAINT fk__new_users__id__groups FOREIGN key (id) REFERENCES groups (id) match simple
);
*/

/*
CREATE TABLE user_orcid(
       user_id integer not null,
       orcid uri not null,
       orcid_validated boolean DEFAULT FALSE,
       -- access to their records is managed in orcid tokens
       -- login via orcid https://members.orcid.org/api/integrate/orcid-sign-in
       -- https://members.orcid.org/api/tutorial/get-orcid-id
       CONSTRAINT pk__user_orcid PRIMARY KEY (user_id, orcid),
       CONSTRAINT fk__user_orcid__user_id__groups FOREIGN key (user_id) REFERENCES groups (id) match simple
);
*/

CREATE TABLE users(
       -- the validated users table, used to isolate validation state and provide a single source of truth
       -- users are only put here when we have authenticated everything
       -- login with orcid only seems like it will be much less hastle but requires us to be a member?
       -- this is NOT the table that manages user permissions

       -- id serial not null,
       -- if you make additions to interlex your user will be preserved even if you delete your account
       -- you can revoke interlex's permission to update your orcid profile, but for the purposes of
       -- provenance your constributions under your username and orcid will be preserved
       -- TODO consider different levels of prov identification?
       -- id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- preferred for 10+
       id integer PRIMARY KEY,
       orcid uri UNIQUE NOT NULL,  -- use orcid oauth NOTE have to do something special for base default curated etc.
       orcid_validated boolean DEFAULT FALSE,
       -- username varchar(40) UNIQUE NOT NULL,  -- e.g. tgbugs  case insensitive via index, limit to 40 chars
       -- email text unique not null,  -- validate with response, this is not used to log you in, this is for prov...
       -- we will only store these after validation and auth but the database can't do that itself
       -- https://members.orcid.org/api/oauth/3legged-oauth
       -- see also https://members.orcid.org/api/workflow/repository#1collect
       -- https://support.orcid.org/knowledgebase/articles/116780-structure-of-the-orcid-identifier&quot
       CONSTRAINT fk__users__id__groups FOREIGN key (id) REFERENCES groups (id) match simple
       -- CONSTRAINT fk__users__username__groups FOREIGN key (username) REFERENCES groups (groupname) match simple
);

CREATE FUNCTION orcid_complete() RETURNS trigger AS $orcid_complete$
       BEGIN
           -- SELECT * FROM user_emails as ue WHERE ue.user_id = NEW.user_id AND ue.email_validated = TRUE LIMIT 1;
           -- IF FOUND AND NOT OLD.orcid_validated AND NEW.orcid_validated THEN -- only try this the first time
           IF EXISTS (SELECT * FROM user_emails as ue WHERE ue.user_id = NEW.id AND ue.email_validated = TRUE LIMIT 1) AND
           NOT OLD.orcid_validated AND NEW.orcid_validated THEN -- only try this the first time
               UPDATE groups as g SET own_role = 'owner' WHERE g.id = NEW.id;
           END IF;
           RETURN NULL;
       END;
$orcid_complete$ language plpgsql;

CREATE TRIGGER orcid_complete AFTER UPDATE ON users FOR each row execute procedure orcid_complete();

CREATE TABLE orcid_tokens(
       orcid uri NOT NULL, 
       orcid_auth_code char(6),
       token_type text,
       access_token uuid,
       refresh_token uuid,
       expires_in integer,  -- annoying...
       token_scope text
);

CREATE TABLE user_emails(
       user_id integer NOT NULL,
       email text UNIQUE NOT NULL,
       email_primary boolean NOT NULL,
       email_validated boolean DEFAULT FALSE,  -- either they click the link or they paste it in somewhere
       -- email + user_id + datetime + valid_for_time + secret -> encrypt it -> put it in a link -> email the link

       -- email_validation_token  -- use the crypto version of this so we don't have to hit the database?
       -- text only option
       -- email_verification_token varchar(40) NOT NULL,  -- TODO how do people do this? on the application side apparently
       -- email_verification_token_expiration timestamp not null DEFAULT CURRENT_TIME + interval '1 hour',
       -- email_verification_email_sent boolean DEFAULT FALSE,
       -- email_verification_link_clicked_time timestamp DEFAULT NULL CHECK NULL OR (email_verification_link_clicked_time < email_verification_token_expiration),
       -- on error we generate a new token and send another email
       CONSTRAINT pk__user_emails PRIMARY KEY (user_id, email),
       -- note fk to users forces orcid which is probably good as it prevents people from simply creating
       -- a group and having an email associated with that group id without ever having the orcid
       -- e.g. base does not have its own email in this system because it never acts as its own agent
       -- it is not clear that this is the best way forward because it means that scibot cannot have its own email
       -- which means that group access and control can only be managed through InterLex, not by sharing access
       -- via some other account, so on the other hand, this means that orgs can't accidentally be torpedoed
       -- if someone looses access, because orgs are not someone, they are potentially many someones
       -- this does mean however that we will have to figure out how to limit the number of orgs that can be created
       CONSTRAINT fk__user_emails__user_id__users FOREIGN key (user_id) REFERENCES users (id) match simple
);

CREATE FUNCTION email_complete() RETURNS trigger AS $email_complete$
       BEGIN
           IF EXISTS (SELECT email_validated FROM user_emails WHERE user_emails.user_id = NEW.user_id AND email_validated = TRUE) AND -- OLD? not u_e?
           NEW.email_validated AND
           EXISTS (SELECT * FROM users as u WHERE u.id = NEW.user_id AND u.orcid_validated = TRUE) THEN
               UPDATE groups as g SET own_role = 'owner' WHERE g.id = NEW.user_id;
              -- fail on the constraints when trying to insert again rather than trying to be smart here
              -- INSERT INTO users (id, orcid, username)
              -- VALUES (NEW.user_id,
                      -- (SELECT orcid from user_orcid where user_orcid.user_id = NEW.user_id),
                      -- (SELECT groupname from groups where groups.id = NEW.user_id));
           END IF;
           RETURN NULL;
       END;
$email_complete$ language plpgsql;

CREATE TRIGGER email_complete AFTER UPDATE ON user_emails FOR EACH row execute procedure email_complete();

CREATE TABLE orgs(
       id integer PRIMARY KEY,
       -- orgname varchar(40) NOT NULL,
       -- note that github has a billing email here as well
       -- and the next step they go to is inviting members
       creator_id integer NOT NULL,
       CONSTRAINT fk__orgs__id__groups FOREIGN key (id) REFERENCES groups (id) match simple,
       -- CONSTRAINT fk__orgs__orgname__groups FOREIGN key (orgname) REFERENCES groups (groupname) match simple,
       CONSTRAINT fk__orgs__creator_id__users FOREIGN key (creator_id) REFERENCES users (id) match simple
);

CREATE FUNCTION org_validated() RETURNS trigger AS $$
       BEGIN
           UPDATE groups as g SET own_role = 'org' WHERE g.id = NEW.id;
           -- that was easy
           RETURN NULL;
       END;
$$ language plpgsql;
CREATE TRIGGER org_validated AFTER INSERT ON orgs FOR EACH ROW EXECUTE PROCEDURE org_validated();

CREATE FUNCTION org_deleted() RETURNS trigger AS $$
       -- the interface will never allow an actual group deletion
       BEGIN
           UPDATE groups as g SET own_role = 'pending' WHERE g.id = OLD.id;
           -- that was easy
           RETURN NULL;
       END;
$$ language plpgsql;
CREATE TRIGGER org_deleted AFTER DELETE ON orgs FOR EACH ROW EXECUTE PROCEDURE org_deleted();

-- CREATE materialized view org_user_view AS SELECT id, username FROM users UNION SELECT id, orgname FROM orgs;

-- this is super inefficient in principle, but I'll tell you what,
-- when we have enough users for it to matter, I will fix it
-- SELECT * FROM groups JOIN users JOIN orgs WHERE groups.groupname = :groupname;
/*
CREATE FUNCTION re_org_user_view() returns trigger AS $$
       BEGIN
           REFRESH MATERIALIZED VIEW org_user_view;
           RETURN NULL;
       END;
$$ language plpgsql;
*/

--CREATE TRIGGER re_user_view AFTER INSERT OR DELETE ON users FOR EACH STATEMENT EXECUTE PROCEDURE re_org_user_view();
--CREATE TRIGGER re_org_view AFTER INSERT OR DELETE ON orgs FOR EACH STATEMENT EXECUTE PROCEDURE re_org_user_view();

CREATE OR REPLACE FUNCTION idFromGroupname(groupname varchar(40), OUT group_id integer) RETURNS integer AS $idFromGroupname$
       -- FIXME run this off groups not org_user_view?
       BEGIN
           SELECT id INTO STRICT group_id FROM groups as g WHERE g.groupname = idFromGroupname.groupname;
           -- usd STRICT to abort a transaction eary if the user does not exist
       END;
$idFromGroupname$ language plpgsql;

CREATE TABLE user_permissions(
       -- TODO need a way to check that the users are validated ... which is why I did it the old way... (ah well)
       group_id integer NOT NULL,  -- user or org, initially only granted curator in their user group
       user_id integer NOT NULL,  -- the fkey prevents groups from having any permissions which is important since can't log in as group
       user_role group_role NOT NULL,
       CHECK (user_role > 'admin' OR user_role = 'admin' AND group_id = 0),
       -- TODO references users vs references new_users due to need to erase users?
       CONSTRAINT pk__user_permissions PRIMARY key (group_id, user_id),  -- users can only have one role at a time
       CONSTRAINT fk__user_permissions__group_id__groups FOREIGN key (group_id) REFERENCES groups (id) match simple,
       CONSTRAINT fk__user_permissions__user_id__users FOREIGN key (user_id) REFERENCES users (id) match simple
);

CREATE TABLE revoked_api_keys(
       key bytea PRIMARY KEY -- TODO pick the proper datatype
       -- we don't need to store API keys that have been generated
       -- unless they have been revoked before their expiration
       -- banning users can also propagate
       -- I don't see any way to avoid this...
       -- set an expiration of... 5 years to limit the total size?
       -- need periodict maintenance routine to clean
);

-- CREATE TRIGGER user no longer pending

CREATE TABLE user_failover_ranks(
       user_id integer NOT NULL,
       rank integer NOT NULL,
       group_id integer NOT NULL DEFAULT 1,  -- curated/default
       CONSTRAINT pk__user_failover_ranks PRIMARY key (user_id, rank),
       CONSTRAINT un__user_failover_ranks UNIQUE (user_id, group_id),
       CONSTRAINT fk__user_failover_ranks__user_id__users FOREIGN key (user_id) REFERENCES users (id) match simple,
       CONSTRAINT fk__user_failover_ranks__other_user_id__users FOREIGN key (group_id) REFERENCES users (id) match simple

);

CREATE type event_type AS enum ('pull requests',
                                -- new term requests vs include requests vs modification requests?
                                'review requests',
                                'changes to terms i track',
                                'changes to ontologies i track'
                                );

CREATE type notification_pref AS enum ('email', 'InterLex feed');
       -- null/none is not recorded and simply removed from the table

CREATE TABLE user_notification_preferences(
       -- include only send
       group_id integer NOT NULL,
       -- use base for all notifications, can store member orgs as well
       -- in practice this may need to be transformed to create 'live' notification lists
       user_id integer NOT NULL,
       event event_type NOT NULL,
       notification notification_pref NOT NULL,
       CONSTRAINT fk__user_email_preferences__user_id__users FOREIGN key (user_id) REFERENCES users (id) match simple
);

CREATE TABLE user_passwords(
       user_id integer PRIMARY KEY NOT NULL, -- only users not orgs may have passwords
       argon2_string text NOT NULL,
       --salt bytea NOT NULL,
       --salted_passworld bytea NOT NULL,
       CONSTRAINT fk__user_passwords__user_id__users FOREIGN key (user_id) REFERENCES users (id) match simple
);

/*
create table user_preferences(
       -- not clear we need this, the data for customization lives a number of different places that
       -- make more operation sense
       user_id integer not null,
       constraint fk__user_preferences__user_id__users foreign key (user_id) references users (id) match simple
);
*/

-- END;
-- $body$ language plpgsql;
