-- interlex-admin interlex_test
-- DO
-- $body$
-- BEGIN

CREATE TABLE perspectives(
       -- perspectives are the full abstraction of groups with regard to how interlex
       -- abstracts sets of definitions and histories
       id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
       group_id integer NOT NULL,
       name text NOT NULL,
       default_group_perspective boolean NOT NULL, -- XXX this is actually the case where name == group.name
       -- group_id and text must be provided, even if the text is generated by
       -- some consistent rule, this is because any realized perspective needs
       -- to be externally referencable independent of the internal id
       CONSTRAINT un__perspectives__group_id_text UNIQUE (group_id, name)
);

CREATE type group_role AS enum (
'admin',
'owner',
'contributor', -- contributors are users that have auto-pull rights when they either directly edit their perspective of a org term or merge their own user perspective to their view of the or org term manually
'curator',
'view', -- really means view-scratch because all non-scratch is public
'org',
'pending',
'deactivated',
'deleted',
'banned',
'erased',
'blacklist',
'builtin');
       -- FIXME TODO do we need a level between owner and contributor that is configurer that can change organization default settings?
       -- FIXME TODO might need banned from organization as well
       -- users with lower enum value (ie admin is lowest) have more privs
       -- permission is only granted, if there is no permission then users can only view
       -- can use ALTER TYPE to insert new values into enums if we need them, much safer than doing it as a table

       -- erased banned + hide all triples they have added (we never really erase) and remove from users table
       -- banned everything that we know of associated with this user id shall be blocked (ip?) the way interlex is built this should almost never need to happen, their content is preserved
       -- curator      can only approve edges contributed by others for inclusion in a given group
                       -- distinct from contributor to manage the curated group where no one can add to that directly
       -- contributor  can add triples in a given group and can create new uris (may want to split these?)
       -- ? mapping    can create new uris and mappings ??? not clear we need this role as distinct from contributor
       -- ? ontology   can create new ontologies and ontology uris and named versions ??? not clear if this as distinct from contributor
       -- owner        can do anything in a particular group users are owners of their own user identical groups
       -- admin        can do anything in any group

CREATE TABLE groups(
       -- working table to store information awaiting verification
       id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- preferred for 10+
       groupname text UNIQUE NOT NULL, -- note the groups lower unique index below
       created_datetime TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
       CHECK (length(groupname) <= 40), -- only upper bound here because sometimes need to disable lower bound
       CHECK (groupname ~* '^[A-Za-z][A-Za-z0-9_-]*$'),  -- no special chars in group names
       CHECK (groupname !~* '(ilx|cde|fde|pde)_.*'),
       CHECK (groupname !~* 'interlex.+'),
       CHECK (groupname !~* '^group.*'),
       CHECK (groupname !~* '^user.*'),
       CHECK (groupname !~* '^test.*'),
       own_role group_role NOT NULL DEFAULT 'pending', -- TODO trigger preventing insert of anyting < pending to enforce data int
       CHECK (own_role > 'admin')
       -- TODO find a way to check that orgs roles >= 'org'

);

ALTER TABLE perspectives ADD CONSTRAINT fk__perspectives__group_id__groups FOREIGN key (group_id) REFERENCES groups (id) match simple;

CREATE UNIQUE INDEX groups_lower_index ON groups (lower(groupname));

CREATE FUNCTION groupname_length_check() returns trigger AS $groupname_length_check$
       BEGIN
           IF (length(NEW.groupname) < 5) THEN
              RAISE exception '% is too short! InterLex usernames and org names must be at least 5 characters long.', NEW.groupname;
           ELSE
              RETURN NEW;
           END IF;
       END;
$groupname_length_check$ language plpgsql;

CREATE TRIGGER groupname_length_check BEFORE INSERT ON groups FOR each row execute procedure groupname_length_check();
-- alter table groups enable trigger groupname_length_check;

 -- ALTER TABLE groups add CONSTRAINT cc__groups__groupname_len_gt_4 CHECK (length(groupname) > 4);
      -- FIXME have to find another way to enforce this since we want _some_ usernames to be shorter
      -- probably do this in the python
      -- prevent the creation of groups with names len < 5
      -- without administrator

-- TODO yes, the indirection provided by perspectives does have real implementation overhead :/
-- CREATE FUNCTION group_ensure_perspective() returns trigger AS $group_ensure_perspective$;

/* -- as long as we use serializable isolation (duh) we don't need this table
CREATE TABLE new_users(
       id integer PRIMARY KEY,
       putative_orcid uri UNIQUE NOT NULL,  -- TODO ask to update on failure? also http://dead.interlex.org/ORCID-SIGNUP-REQUIRED
       -- That orcid does not exist!
       orcid_validated boolean DEFAULT FALSE,
       email_validated boolean DEFAULT FALSE,
       CONSTRAINT fk__new_users__id__groups FOREIGN key (id) REFERENCES groups (id) match simple
);
*/

/*
CREATE TABLE user_orcid(
       user_id integer not null,
       orcid uri not null,
       orcid_validated boolean DEFAULT FALSE,
       -- access to their records is managed in orcid tokens
       -- login via orcid https://members.orcid.org/api/integrate/orcid-sign-in
       -- https://members.orcid.org/api/tutorial/get-orcid-id
       CONSTRAINT pk__user_orcid PRIMARY KEY (user_id, orcid),
       CONSTRAINT fk__user_orcid__user_id__groups FOREIGN key (user_id) REFERENCES groups (id) match simple
);
*/

CREATE TABLE orcid_metadata(
       orcid uri PRIMARY KEY,
       name text,
       token_type text,
       token_scope text,
       token_access uuid NOT NULL,  -- make sure we have at least this, even for testing
       token_refresh uuid,
       lifetime_seconds integer,
       openid_token text
);

CREATE TABLE users(
       -- the validated users table, used to isolate validation state and provide a single source of truth
       -- users are only put here when we have authenticated everything
       -- login with orcid only seems like it will be much less hastle but requires us to be a member?
       -- this is NOT the table that manages user permissions
       -- XXX the above is false and dated information, users go in here immediately

       -- id serial not null,
       -- if you make additions to interlex your user will be preserved even if you delete your account
       -- you can revoke interlex's permission to update your orcid profile, but for the purposes of
       -- provenance your constributions under your username and orcid will be preserved
       -- TODO consider different levels of prov identification?
       -- id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- preferred for 10+
       id integer PRIMARY KEY,
       orcid uri UNIQUE references orcid_metadata (orcid),  -- use orcid oauth NOTE have to do something special for base default curated etc.
       -- orcid_validated TIMESTAMP WITH TIME ZONE DEFAULT NULL,
       -- username varchar(40) UNIQUE NOT NULL,  -- e.g. tgbugs  case insensitive via index, limit to 40 chars
       -- email text unique not null,  -- validate with response, this is not used to log you in, this is for prov...
       -- we will only store these after validation and auth but the database can't do that itself
       -- https://members.orcid.org/api/oauth/3legged-oauth
       -- see also https://members.orcid.org/api/workflow/repository#1collect
       -- https://support.orcid.org/knowledgebase/articles/116780-structure-of-the-orcid-identifier&quot
       CONSTRAINT fk__users__id__groups FOREIGN key (id) REFERENCES groups (id) match simple
       -- CONSTRAINT fk__users__username__groups FOREIGN key (username) REFERENCES groups (groupname) match simple
);

CREATE FUNCTION orcid_no_update_to_null() RETURNS trigger AS $orcid_no_update_to_null$
BEGIN
IF OLD.orcid IS NOT NULL and NEW.orcid IS NULL THEN
    RAISE EXCEPTION 'Cannot update a non-null orcid to be null.';
ELSE
    RETURN NEW;
END IF;
END;
$orcid_no_update_to_null$ language plpgsql;

CREATE TRIGGER orcid_no_update_to_null BEFORE UPDATE ON users FOR each row execute procedure orcid_no_update_to_null();

CREATE FUNCTION orcid_complete() RETURNS trigger AS $orcid_complete$
       BEGIN
           -- SELECT * FROM user_emails as ue WHERE ue.user_id = NEW.user_id AND ue.email_validated = TRUE LIMIT 1;
           -- IF FOUND AND NOT OLD.orcid_validated AND NEW.orcid_validated THEN -- only try this the first time
           IF OLD.orcid IS NULL AND NEW.orcid IS NOT NULL AND -- only try this the first time
              EXISTS (SELECT * FROM user_emails as ue WHERE ue.user_id = NEW.id AND ue.email_validated IS NOT NULL LIMIT 1) THEN
               UPDATE groups as g SET own_role = 'owner' WHERE g.id = NEW.id;
           END IF;
           RETURN NULL;
       END;
$orcid_complete$ language plpgsql;

CREATE TRIGGER orcid_complete AFTER UPDATE ON users FOR each row execute procedure orcid_complete();

CREATE TABLE user_emails(
       user_id integer NOT NULL,
       email text UNIQUE NOT NULL,
       email_primary boolean NOT NULL,
       email_validated TIMESTAMP WITH TIME ZONE DEFAULT NULL,  -- either they click the link or they paste it in somewhere
       created_datetime TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
       -- email + user_id + datetime + valid_for_time + secret -> encrypt it -> put it in a link -> email the link

       -- email_validation_token  -- use the crypto version of this so we don't have to hit the database?
       -- text only option
       -- email_verification_token varchar(40) NOT NULL,  -- TODO how do people do this? on the application side apparently
       -- email_verification_token_expiration timestamp not null DEFAULT CURRENT_TIME + interval '1 hour',
       -- email_verification_email_sent boolean DEFAULT FALSE,
       -- email_verification_link_clicked_time timestamp DEFAULT NULL CHECK NULL OR (email_verification_link_clicked_time < email_verification_token_expiration),
       -- on error we generate a new token and send another email
       CONSTRAINT pk__user_emails PRIMARY KEY (user_id, email),
       -- note fk to users forces orcid which is probably good as it prevents people from simply creating
       -- a group and having an email associated with that group id without ever having the orcid
       -- e.g. base does not have its own email in this system because it never acts as its own agent
       -- it is not clear that this is the best way forward because it means that scibot cannot have its own email
       -- which means that group access and control can only be managed through InterLex, not by sharing access
       -- via some other account, so on the other hand, this means that orgs can't accidentally be torpedoed
       -- if someone looses access, because orgs are not someone, they are potentially many someones
       -- this does mean however that we will have to figure out how to limit the number of orgs that can be created
       CONSTRAINT fk__user_emails__user_id__users FOREIGN key (user_id) REFERENCES users (id) match simple
);

CREATE FUNCTION email_complete() RETURNS trigger AS $email_complete$
       BEGIN
           IF NEW.email_validated IS NOT NULL AND
           NOT EXISTS (SELECT ue.email_validated FROM user_emails AS ue WHERE ue.user_id = NEW.user_id AND ue.email != NEW.email AND ue.email_validated IS NOT NULL) AND -- OLD? not u_e?
           EXISTS (SELECT * FROM users as u WHERE u.id = NEW.user_id AND u.orcid IS NOT NULL) THEN
               UPDATE groups as g SET own_role = 'owner' WHERE g.id = NEW.user_id;
               --XXX don't need this extra check because we check whether another email was already validated in which case this trigger will have already run
               --IF NOT EXISTS (SELECT g.own_role FROM groups as g WHERE g.id = NEW.user_id AND g.own_role = 'owner') THEN -- only the first time an email is validated
               --END IF;
              -- fail on the constraints when trying to insert again rather than trying to be smart here
              -- INSERT INTO users (id, orcid, username)
              -- VALUES (NEW.user_id,
                      -- (SELECT orcid from user_orcid where user_orcid.user_id = NEW.user_id),
                      -- (SELECT groupname from groups where groups.id = NEW.user_id));
           END IF;
           RETURN NULL;
       END;
$email_complete$ language plpgsql;

CREATE TRIGGER email_complete AFTER UPDATE ON user_emails FOR EACH row execute procedure email_complete();

CREATE TABLE emails_validating(
       -- TODO consider using something like pg_cron to periodically cull these
       user_id integer NOT NULL,
       email text NOT NULL,
       token text UNIQUE NOT NULL,
       created_datetime TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
       -- delays seconds is time until can validate, helps with 2
       -- things, a slight rate limit on new accounts, and more
       -- importantly provides a window where various security scanner
       -- nonsense cannot accidentally trigger the link, adjust accordingly
       delay_seconds integer NOT NULL DEFAULT 60,
       lifetime_seconds integer NOT NULL DEFAULT 900, -- default to 15 minutes
       CHECK (delay_seconds <= lifetime_seconds),
       PRIMARY KEY (user_id, email),
       FOREIGN KEY (user_id, email) REFERENCES user_emails (user_id, email)
);

CREATE OR REPLACE FUNCTION email_verify_complete(token text) RETURNS text AS $email_verify_complete$
DECLARE
out_groupname text;
BEGIN
    IF EXISTS (
       SELECT * FROM emails_validating AS ev
       WHERE ev.token = email_verify_complete.token
       AND CURRENT_TIMESTAMP > ev.created_datetime + make_interval(secs := ev.delay_seconds)
       AND CURRENT_TIMESTAMP < ev.created_datetime + make_interval(secs := ev.lifetime_seconds)) THEN
           SELECT g.groupname INTO out_groupname
           FROM groups AS g
           JOIN users AS u ON u.id = g.id
           JOIN emails_validating AS ev ON ev.user_id = u.id AND ev.token = email_verify_complete.token;

           WITH evs AS (SELECT * FROM emails_validating AS ev WHERE ev.token = email_verify_complete.token)
           UPDATE user_emails AS ue SET email_validated = CURRENT_TIMESTAMP FROM evs WHERE ue.email = evs.email AND ue.user_id = evs.user_id;
           DELETE FROM emails_validating AS ev WHERE ev.token = email_verify_complete.token;

           RETURN out_groupname;
    ELSIF EXISTS (
    SELECT * FROM emails_validating AS ev
    WHERE ev.token = email_verify_complete.token
    AND CURRENT_TIMESTAMP <= ev.created_datetime + make_interval(secs := ev.delay_seconds)) THEN
        -- <= to ensure that attempts to start and complete in the same transaction fail for an explicable reason
        -- also because the token is only valid AFTER time, not at the same moment
        RAISE EXCEPTION 'too early, verification link not active';
    ELSIF EXISTS (
    SELECT * FROM emails_validating AS ev
    WHERE ev.token = email_verify_complete.token
    AND CURRENT_TIMESTAMP > ev.created_datetime + make_interval(secs := ev.lifetime_seconds)) THEN
        RAISE EXCEPTION 'too late, verification link has expired';
    ELSIF NOT EXISTS (SELECT * FROM emails_validating AS ev WHERE ev.token = email_verify_complete.token) THEN
        RAISE EXCEPTION 'unknown email verification token';
    ELSE
        RAISE EXCEPTION 'how did you get here?';
    END IF;
END;
$email_verify_complete$ language plpgsql;

CREATE TABLE orgs(
       id integer PRIMARY KEY,
       -- orgname varchar(40) NOT NULL,
       -- note that github has a billing email here as well
       -- and the next step they go to is inviting members
       creator_id integer NOT NULL,
       created_datetime TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
       CONSTRAINT fk__orgs__id__groups FOREIGN key (id) REFERENCES groups (id) match simple,
       -- CONSTRAINT fk__orgs__orgname__groups FOREIGN key (orgname) REFERENCES groups (groupname) match simple,
       CONSTRAINT fk__orgs__creator_id__users FOREIGN key (creator_id) REFERENCES users (id) match simple
);

CREATE FUNCTION org_validated() RETURNS trigger AS $$
       BEGIN
           UPDATE groups AS g SET own_role = 'org' WHERE g.id = NEW.id;
           -- that was easy
           RETURN NULL;
       END;
$$ language plpgsql;
CREATE TRIGGER org_validated AFTER INSERT ON orgs FOR EACH ROW EXECUTE PROCEDURE org_validated();

CREATE FUNCTION org_deleted() RETURNS trigger AS $$
       -- the interface will never allow an actual group deletion
       BEGIN
           UPDATE groups AS g SET own_role = 'deleted' WHERE g.id = OLD.id;
           -- that was easy
           RETURN NULL;
       END;
$$ language plpgsql;
CREATE TRIGGER org_deleted AFTER DELETE ON orgs FOR EACH ROW EXECUTE PROCEDURE org_deleted(); -- FIXME I don't think we actually delete orgs ???

-- CREATE materialized view org_user_view AS SELECT id, username FROM users UNION SELECT id, orgname FROM orgs;

-- this is super inefficient in principle, but I'll tell you what,
-- when we have enough users for it to matter, I will fix it
-- SELECT * FROM groups JOIN users JOIN orgs WHERE groups.groupname = :groupname;
/*
CREATE FUNCTION re_org_user_view() returns trigger AS $$
       BEGIN
           REFRESH MATERIALIZED VIEW org_user_view;
           RETURN NULL;
       END;
$$ language plpgsql;
*/

--CREATE TRIGGER re_user_view AFTER INSERT OR DELETE ON users FOR EACH STATEMENT EXECUTE PROCEDURE re_org_user_view();
--CREATE TRIGGER re_org_view AFTER INSERT OR DELETE ON orgs FOR EACH STATEMENT EXECUTE PROCEDURE re_org_user_view();

CREATE OR REPLACE FUNCTION idFromGroupname(groupname text, OUT group_id integer) RETURNS integer AS $idFromGroupname$
       -- FIXME run this off groups not org_user_view?
       BEGIN
           SELECT id INTO STRICT group_id FROM groups as g WHERE g.groupname = idFromGroupname.groupname;
           -- use STRICT to abort a transaction early if the user does not exist
       END;
$idFromGroupname$ language plpgsql;

CREATE TABLE user_permissions(
       -- TODO need a way to check that the users are validated ... which is why I did it the old way... (ah well)
       group_id integer NOT NULL,  -- user or org, initially only granted curator in their user group
       user_id integer NOT NULL,  -- the fkey prevents groups from having any permissions which is important since can't log in as group
       CHECK (group_id != user_id),  -- that's what own_role is for
       user_role group_role NOT NULL,
       CHECK ((user_role > 'admin' AND user_role <= 'view') OR user_role = 'admin' AND group_id = 0),
       -- TODO references users vs references new_users due to need to erase users?
       CONSTRAINT pk__user_permissions PRIMARY key (group_id, user_id),  -- users can only have one role at a time
       CONSTRAINT fk__user_permissions__group_id__groups FOREIGN key (group_id) REFERENCES groups (id) match simple,
       CONSTRAINT fk__user_permissions__user_id__users FOREIGN key (user_id) REFERENCES users (id) match simple
);

CREATE FUNCTION check_valid_user_user_role() RETURNS trigger AS $$
       -- need to limit user to user roles to view
       BEGIN
           IF EXISTS (SELECT * FROM users as u WHERE u.id = NEW.group_id) THEN
              IF NEW.user_role != 'view' THEN
                 RAISE exception 'The only valid user -> user permissions is view. % is not valid.', NEW.user_role;
              END IF;
           END IF;
           RETURN NULL;
       END;
$$ language plpgsql;

CREATE TRIGGER check_valid_user_user_role BEFORE INSERT ON user_permissions FOR EACH ROW EXECUTE PROCEDURE check_valid_user_user_role();

CREATE TYPE key_types AS ENUM (
'personal', -- standard
'refresh', -- not implemented
'web' -- possibly to be used by the web client with short access
);

CREATE TYPE key_scopes AS ENUM (
'admin', -- no checks, just audit
'settings-all',  -- allow modification of settings and group settings
'settings-only',  -- allow modification of only user settings
'user-all', -- no checks within user, but must check user's permissions within a group for everything else (constant time side channel issues here on 404)
'user-only', -- issued user only, any mismatch 404s cannot be used for operations on other groups
'read-all', -- like user-all but only read operations are allowed, permissions to view other groups scratch space work this way, useful for e.g. dashboards
'read-only' -- like user-only but only read operations are allowed

);

CREATE TABLE api_keys(
       --key bytea PRIMARY KEY, -- FIXME this should probably actually be text because we aren't storing as bytes?
       user_id integer NOT NULL references users (id), -- only users can have api keys
       key text PRIMARY KEY,
       CHECK (key ~* '^ix[prw]_[0-9A-Za-z]+$'),
       key_type key_types NOT NULL,
       CHECK (substring(key_type::text, 1, 1) = substring(key, 3, 1)),
       key_scope key_scopes NOT NULL,
       created_datetime TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
       lifetime_seconds integer, -- null means never expires FIXME likely want a constraint on max lifetimes for web tokens
       CHECK (lifetime_seconds IS NULL OR lifetime_seconds > 60), -- minimum 1 mintue to avoid accidentally minting api keys the expire immediately
       revoked_datetime TIMESTAMP WITH TIME ZONE,
       note text,
       CHECK ((note ~* '^\S+') AND (note ~* '\S+$')) -- no leading and no trailing whitespace
);

CREATE INDEX api_keys_user_id_index ON api_keys (user_id);

CREATE OR REPLACE FUNCTION api_keys_ensure_invars() RETURNS trigger AS $api_keys_ensure_owner$
DECLARE
max_total integer;
max_active integer;
BEGIN
    -- ensure user is owner
    IF NOT EXISTS (SELECT * FROM users AS u JOIN groups AS g ON u.id = g.id AND g.own_role = 'owner' WHERE u.id = NEW.user_id) THEN
       RAISE EXCEPTION 'User lacks sufficient privileges to create an api key. User own_role is %.', (SELECT own_role FROM groups WHERE id = NEW.user_id);
    END IF;

    -- ensure user has admin role in empty group before granting them a key with scope admin
    IF NEW.key_scope = 'admin' AND NOT EXISTS (SELECT * FROM user_permissions AS up WHERE up.user_id = NEW.user_id AND up.group_id = 0 AND up.user_role = 'admin') THEN
       RAISE EXCEPTION 'User lacks sufficient privileges to create an api key with admin scope.';
    END IF;

    -- FIXME web keys might rotate on a shorter time, need to check with frontend on that
    -- ensure that non-admin users don't have more than quota total keys
    SELECT greatest(uq.maxv, q.maxv) INTO max_total
    FROM quotas AS q
    LEFT JOIN user_quotas AS uq ON uq.qtype = q.qtype AND uq.user_id = NEW.user_id
    WHERE q.qtype = 'api-key-total';

    IF ((SELECT count(*) FROM api_keys WHERE user_id = NEW.user_id) >= max_total) THEN
       RAISE EXCEPTION 'User has max total api_keys = %.', max_total;
    END IF;

    -- ensure that non-admin users don't have more than quota active keys
    SELECT greatest(uq.maxv, q.maxv) INTO max_active
    FROM quotas AS q
    LEFT JOIN user_quotas AS uq ON uq.qtype = q.qtype AND uq.user_id = NEW.user_id
    WHERE q.qtype = 'api-key-active';

    IF ((SELECT count(*) FROM api_keys WHERE user_id = NEW.user_id) >= max_active) THEN
       RAISE EXCEPTION 'User has max active api_keys = %.', max_active;
    END IF;

    -- XXX NOTE that admin scope on a key only applies if admin still has empty group user role admin
    -- we already check own_role < pending for normal users, but admin hasn't been handled yet
    -- TODO ensure that admin's can't accidentally revoke admin status, for now revoking admin requires db access
    RETURN NEW;

END;
$api_keys_ensure_owner$ language plpgsql;

CREATE TRIGGER api_keys_ensure_invars BEFORE INSERT ON api_keys FOR EACH ROW EXECUTE PROCEDURE api_keys_ensure_invars();
-- TODO trigger for post user role changes to revoke any keys beyond our scope/role checks

CREATE TABLE expiration_intervals(
       thing text PRIMARY KEY,
       duration interval
);

INSERT INTO expiration_intervals (thing, duration) VALUES
        -- TODO surface this in documentation about deletion times
       ('api-key', '90 days'),
       ('user', '1 week'),
        -- 2 days may seem short, but we auto un-expire if needed
       ('email', '2 days'),
       --('orcid', '2 days'),
       ('email-token', '30 mins') -- we probably don't run cull every 30 mins, but the point stands
;

CREATE OR REPLACE FUNCTION cullExpiredThings() RETURNS void AS $cullExpiredThings$
DECLARE
api_key_done_expire_dur interval;
user_email_unverified_expire_dur interval;
--user_orcid_unverified_expire_dur interval;
user_account_unverified_expire_dur interval;
email_token_unverified_expire_dur interval;
BEGIN
       select duration into api_key_done_expire_dur from expiration_intervals where thing = 'api_key';
       select duration into user_account_unverified_expire_dur from expiration_intervals where thing = 'user';
       select duration into user_email_unverified_expire_dur from expiration_intervals where thing = 'email';
       --select duration into user_orcid_unverified_expire_dur from expiration_intervals where thing = 'orcid';
       select duration into email_token_unverified_expire_dur from expiration_intervals where thing = 'email-token';
       -- 2 days may seem short, but users can add back if they need in the extremely rare case where
       -- they somehow can't verify their account but have managed to remember their password
       -- the actual way we expire emails and is to prepend 'EXPIRED user@example.org' since the type matches
       -- and it will prevent a user from squatting on the wrong email, easy for them to change later and
       -- if they reverify we can auto reset within the 1 week
       -- for orcids we expire by appending -EXPIRED to the end of the url

       SELECT * FROM api_keys
       -- FIXME TODO i think it is ok to cull expired api keys because
       -- they aren't going to be showing up in logs anyway and we
       -- have formal prov systems for everything else, but need to
       -- review to make sure
       WHERE ((revoked_datetime                           IS NOT NULL
               AND
               revoked_datetime + api_key_done_expire_dur >= CURRENT_TIMESTAMP)
              OR
              (created_datetime + make_interval(secs := lifetime_seconds)                           >= CURRENT_TIMESTAMP
               AND
               created_datetime + make_interval(secs := lifetime_seconds) + api_key_done_expire_dur >= CURRENT_TIMESTAMP));

       SELECT * FROM user_emails
       WHERE email_verified IS NULL AND created_datetime + user_email_unverivied_expire_dur >= CURRENT_TIMESTAMP;

       --SELECT * FROM users
       --WHERE orcid_verified IS NULL AND created_datetime + user_orcid_unverified_expire_dur >= CURRENT_TIMESTAMP;

       SELECT * FROM users AS u JOIN groups AS g ON g.id = u.id
       WHERE g.own_role = 'pending'
         AND g.created_datetime + user_account_unverified_expire_dur >= CURRENT_TIMESTAMP;

END;
$cullExpiredThings$ language plpgsql;

CREATE TABLE revoked_api_keys(
       key bytea PRIMARY KEY -- TODO pick the proper datatype
       -- we don't need to store API keys that have been generated
       -- unless they have been revoked before their expiration
       -- banning users can also propagate
       -- I don't see any way to avoid this...
       -- set an expiration of... 5 years to limit the total size?
       -- need periodict maintenance routine to clean
);

-- CREATE TRIGGER user no longer pending

CREATE TABLE user_failover_ranks(
       user_id integer NOT NULL,
       rank integer NOT NULL,
       group_id integer NOT NULL DEFAULT 1,  -- curated/default
       CONSTRAINT pk__user_failover_ranks PRIMARY key (user_id, rank),
       CONSTRAINT un__user_failover_ranks UNIQUE (user_id, group_id),
       CONSTRAINT fk__user_failover_ranks__user_id__users FOREIGN key (user_id) REFERENCES users (id) match simple,
       CONSTRAINT fk__user_failover_ranks__other_user_id__users FOREIGN key (group_id) REFERENCES users (id) match simple

);

CREATE type event_type AS enum ('pull requests',
                                -- new term requests vs include requests vs modification requests?
                                'review requests',
                                'changes to terms i track',
                                'changes to ontologies i track'
                                );

CREATE type notification_pref AS enum ('email', 'InterLex feed');
       -- null/none is not recorded and simply removed from the table

CREATE TABLE user_notification_preferences(
       -- include only send
       group_id integer NOT NULL,
       -- use base for all notifications, can store member orgs as well
       -- in practice this may need to be transformed to create 'live' notification lists
       user_id integer NOT NULL,
       event event_type NOT NULL,
       notification notification_pref NOT NULL,
       CONSTRAINT fk__user_email_preferences__user_id__users FOREIGN key (user_id) REFERENCES users (id) match simple
);

CREATE TABLE user_passwords(
       user_id integer PRIMARY KEY NOT NULL, -- only users not orgs may have passwords
       argon2_string text NOT NULL, -- XXX this could also have UNIQUE as double insurance that password salts are different but that seems overkill?
       CHECK (argon2_string ~* '^\$argon2id\$'), -- catch boneheaded inserts
       --salt bytea NOT NULL,
       --salted_passworld bytea NOT NULL,
       CONSTRAINT fk__user_passwords__user_id__users FOREIGN key (user_id) REFERENCES users (id) match simple
);

-- some overly simplified abuse control mechanisms

CREATE TYPE quota_types AS ENUM (
-- FIXME TODO may need to differentiate personal and web api keys?
'api-key-active',
'api-key-total',
'email-total'
);

CREATE TABLE quotas( -- default quota values
       qtype quota_types PRIMARY KEY,
       minv integer NOT NULL DEFAULT 0,
       maxv integer NOT NULL
);

INSERT INTO quotas (qtype, maxv) VALUES
       ('api-key-active', 20),
       ('api-key-total', 100),
       ('email-total', 10); -- really even 5 is is probably overkill

CREATE TABLE user_quotas(
       user_id integer references users (id),
       qtype quota_types,
       PRIMARY KEY (user_id, qtype),
       minv integer NOT NULL DEFAULT 0,
       maxv integer NOT NULL
);

/*
create table user_preferences(
       -- not clear we need this, the data for customization lives a number of different places that
       -- make more operation sense
       user_id integer not null,
       constraint fk__user_preferences__user_id__users foreign key (user_id) references users (id) match simple
);
*/

-- END;
-- $body$ language plpgsql;
