-- CONNECT TO interlex_test USER "interlex-admin";

CREATE TABLE export_rules(
       -- id serial not null,
       id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- preferred for 10+
       group_id integer NOT NULL,  -- less relevant but important for prov
       rule text NOT NULL,  -- FIXME TODO how to encode these? can we avoid parsing?
       CONSTRAINT fk__export_rules__group_id__groups FOREIGN key (group_id) REFERENCES groups (id) match simple
);

CREATE TABLE ontologies(
       id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- preferred for 10+
       produce_ontology_iri text NOT NULL UNIQUE,  -- 'named' subgraphs
       source_ontology_iri uri NOT NULL UNIQUE,
       loaded_from_iri -- this fellow is different

       -- how to make a: b: and b: b: equivalent? make the produce the primary key
       -- each iri may only occurce once, if the source is external then it is external, if it is internal then it is internal
       owner_group_id integer NOT NULL,
       -- triple_id integer NOT NULL UNIQUE,  -- to the the rdf:type owl:Ontology triple, need to find a way to enforce
       -- i think triple_id is the right way to enforce this because that way we explicitly delimit the issues with rdf:type conflation?
       -- no?
       -- this works for external ontologies too, and will allow us to pull off the /uberon/ontologies/obo/uberon.owl

       -- this is the one place where we put triples with non-base uris into the triples
       -- because they do not get interlex ids, but only the originator of the file gets that uri
       -- versions are generated not stored, so additions/deletions are always made against the
       -- originating user's iri and are qualified just like any other change
       -- will need a way to identify identical export rule sets
       -- ont_full uri not null,  -- 
       -- TODO do we store the ontology annotation data as triples or what? like title etc
       -- we should just be able to store them using either the interlex id for the ontology (bad idea?)
       -- or using the full path to the ontology file, also a bad idea, so maybe assigning interlex ids to user
       -- ontologies isn't the worst idea? or maybe we need /base/ontologies/ilxont_1234567
       -- basically we need something that will let /own/other-user/ontologies/my/ont/bob.ttl to adjust iris correctly
       -- and still get all the relevant metadata, I think /user/ontologies/my/ont/bob.ttl will work since we can
       -- just use a replacement rule since we will know the full uri for the original source
       -- sujbect_qualifier integer not null,  -- this is probably too granular but the idea of subject qualifiers is useful
       -- constraint pk__ontologies primary key (id)
       CONSTRAINT fk__ontologies__group_id__group FOREIGN key (group_id) REFERENCES groups (id) match simple
);

CREATE TABLE ontologies_external(
       -- internal owner tracking is much easier and easier to control because POST to ontologies/<path> will be per user/org
       ontology_iri uri PRIMARY KEY,
       owner_group_id integer NOT NULL,
       CONSTRAINT fk__ontologies_external__owner_group_id__groups FOREIGN key (owner_group_id) REFERENCES groups (id) match simple
);

CREATE TABLE uris(
       group_id integer NOT NULL,
       ilx_id char(7) NOT NULL,  -- TODO how to enforce the 'no changing the ilx_id' block delete?
       uri_path text NOT NULL,

       -- uri_full uri not null,  -- yes or no?
       -- branch_private default false  -- TOOD this needs to be managed elsewhere?
       -- terminal -> branch changes? one way to cope is always resolve /branch/ -> branch
       -- but then we have to know which are branches...
       -- unique on user_id ilx_id as discussed in the spec or what?
       CONSTRAINT pk__uris PRIMARY KEY (group_id, uri_path), -- you may only map a uri path once per group
       CONSTRAINT fk__uris__group_id__groups FOREIGN key (group_id) REFERENCES groups (id) match simple,
       CONSTRAINT fk__uris__ilx_id__interlex_ids FOREIGN key (ilx_id) REFERENCES interlex_ids (id) match simple
);

-- CREATE TRIGGER uris_static ON uris BEFORE UPDATE OR DELETE -- dealt with via no update or delete permissions for interlex-user

CREATE TABLE uri_branches(
       -- uris that may or may not be resolvable but that users want to make private or other things
       -- things can only start private, they cannot be unprivated
       group_id integer NOT NULL,
       branch_path text NOT NULL,
       public boolean NOT NULL,
       CONSTRAINT fk__uri_branches__group_id__groups FOREIGN key (group_id) REFERENCES groups (id) match simple
);

CREATE FUNCTION branch_no_hide() returns trigger AS $branch_no_hide$
       BEGIN
           IF NEW.public THEN
              RAISE exception 'Branch % is already public, you cannot make it private!', NEW.branch_path;
           END IF;
           RETURN NULL;
       END;
$branch_no_hide$ language plpgsql;

CREATE TRIGGER branch_no_hide before update ON uri_branches FOR each row execute procedure branch_no_hide();

CREATE TABLE curies(
       -- computing curied representations can be quite expensive
       -- TODO this needs history of some kind for versions
       group_id integer NOT NULL, -- if the user has not set curies fail over to default user
       curie_prefix varchar(30) NOT NULL CHECK (curie_prefix NOT LIKE '%:%'),  -- is case sensitive, TODO validate against the w3c/ietf spec
       iri_prefix uri NOT NULL,
       -- TODO what uniqueness constraints are we going to impose here?
       CONSTRAINT pk__curies PRIMARY key (group_id, curie_prefix, iri_prefix),
       CONSTRAINT fk__curies__group_id__group FOREIGN key (group_id) REFERENCES groups (id) match simple
);

