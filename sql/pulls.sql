/*
ah voting systems
basically we are going to recapitulate various forms of government here

the basic model is 3 phases, the second of which is optional
(looks and aweful lot like lower house -> upper house -> executive ...)

1 drafting
2 review
3 final sign off

an individual pr can go through many, many rounds of revisions, what we
need to do is provide a set of primitives that allow curators, reviewers,
and maintainers to move terms effectively though the system

specifically curators should be able to draft and submit rapidly
and construct or select a group of reviewers and notify them

reviewers should be able to review the term(s), make their decisions
and vote accordingly, or decide collectively and have someone take
delegated action etc. so e.g. everyone else says, we've talked this
over with tom and agree with the action he will take and don't need
the formality of voting, so either the system is quorum of 1 or let
the maintainer do it, or whatever, or, formally, we are delegating
our collective decision and here is my chit saying i want tom to,
decide, and tom wants this because he wants a record of that so he
can't later be accused of going rogue etc. operationally though this
is just as much work for each reviewer as clicking approve ...
since it is two phase, just click approve, or do it in committee and
be able to send the list of stuff to look at around, i think that is
likely the hardest part ... getting everyone on the same page ... so
reviewer pools that show common pull requests is probably a good idea

reminder though, if someone creates a term then the curated view should
almost always list them as a reviewer for pulls into curated, i think
it might be possible to grant reviewer/curator/editor status on specific
terms to specific individuals, sort of like subsystem maintainers ...
would require a perspective_term_roles table ...
*/

CREATE TYPE pull_status_type AS ENUM (
       'draft',
       'review', -- some workflows will skip this, review can be advisory rather than mandatory, the review status is for cases where review is mandatory
       'pending', -- aka final sign off
       'merged',
       'closed',
       'locked');

CREATE TABLE pull_requests(
       -- if you waw
       id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
       subject uri NOT NULL,
       from_perspective integer NOT NULL,
       to_perspective integer NOT NULL, -- the owner(s) of the to_perspective act as the executive branch for final signoff
       original_from_identity bytea NOT NULL,
       original_to_identity bytea NOT NULL,
       -- TODO I think submitting_user can be recovered by looking at the details of from_perspective but
       -- we know that the process requires a submitting user so we record it here

       -- there is a possibility that someone might see some work and
       -- submit a pull on behalf of someone else, but i think that is
       -- a bad workflow, they should merge and then pull from their
       -- own, the real reason to have submitting_user is when there
       -- are multiple roles with at least curator level permissions
       -- in a from organization and we need to know who actually
       -- submitted the request
       submitting_user integer NOT NULL references users (id),
       created_datetime TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
       blind boolean DEFAULT FALSE, -- TODO for some review processes the mere knowledge of the existence of the PR is a problem, when the pr is created the submitter can be given the option to blind if the perspective allows it
       status pull_status_type NOT NULL DEFAULT 'pending' -- set to review if review is required
);

/*
for group perspectives and user perspectives the default
without being in this table is the owner(s)

we need one more level of indirection because we want
to be able to provide groups of reviewers a single page
that they can all look at and review in common, and e.g.
all cast their vote at the same time (now does as
perspective_default_committee) yeah committee
is a bit strong, but board, panel, pool, etc. all have
overlapping meanings in software etc.
*/
CREATE TABLE committees(
/*
TODO the history of these committees should also be tracked in the
triples table, these are used to maintain the invariants that are
needed for operations

example name SAWG
*/
       id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
       name text,
       description text,
       CHECK ((name ~* '^\S+') AND (name ~* '\S+$')),
       CHECK ((description ~* '^\S+') AND (description ~* '\S+$'))
);

/*
-- argh, point in time problems, committees can change members, but pull reviewers must be exact and not change after the fact
-- also in the flow it means that if there is an open pull request and new members are added to the review committee then they
-- should be include automatically, i think we only need to record final decisions by individual reviewers, we don't need to
-- know who we actually on the committee we can use the history table for that, we just need to know that the rules at the time
-- were satisfied
CREATE TABLE pull_reviewers( -- TODO convert to pull votes which is what will be recorded if needed
       -- we aren't doing committees of one
       -- for one offs just pull in the reviewers
       -- and we can create a pull request -> committee function
       pull_id integer references pull_requests (id),
       -- pull reviewers are separate from the to_perspective owners(s)
       reviewer integer references users (id),
       primary key (pull_id, reviewer)
);
*/

/* -- superseded by the review_processes table which is the proper abstraction
CREATE TABLE pull_committees(
       -- I'm guessing 99% of pulls will only have one review committee
       -- however there will be cases where there are terms that sit at
       -- a boundary between two domains and then you will need two sets
       -- of expertise
       pull_id integer references pull_requests (id),
       -- TODO populate committee by default from the to_perspective default setting unless submitting user changes
       -- will also want to be able to provide a list of recently used committees by the user/to_perspective, which
       -- we can get by querying the n most recent pull requests for user and m most recent for to_perspective
       committee integer references committees (id),
       primary key (pull_id, committee)
);
*/

/*
old thinking
-- the default that happens if there are no responses within a time window
-- FIXME actually this is confusing
-- any one person can approve is NOT the same as if no one does anything then it will be approved, we don't want to auto close anything
'auto',
'vote-out', -- reviewers must vote a change out otherwise it will happen
'vote-in', -- reviewers must vote a change in, otherwise it will not happen, usually there is no duration
--'approve-unless',
--'must-approve',

'approve-unless-anyone-says-no-before-time', 'deny-if-anyone-says-no',
'approve-if-anyone-says-yes', 'deny-unless-anyone-says-yes-before-time',

'approve-unless-veto',
'deny-unless-confirm',
'at-least-n-reviewers-must-approve',
'at-most-n-reviewers-may-deny',
'approve', -- this means that if nothing is done by the time limit the pr will be closed
'deny', -- veto
'change-will-become-effective-unless-n-deny', -- and then quorum
'change-will-not-become-effective-unless-n-approve',

-- 'up-or-down',
-- 'up-or-down-with-quorum',
-- 'disabled' -- not sure if we need this, all the cases that come to mind quickly produce a counter example, e.g. utility pairwise like tom's view of uberon might need to accept changes from a maintainer, having provisional pull requests for external ontologies is critical for having a point of reference when we want to issue a pull to the real upstream repo, etc.
*/

CREATE TYPE vote_types AS ENUM (
       -- FIXME I think accept/reject is a better pairing for this? obvs we tweak wording for interface
       'approve', -- combine this with zero duration to produce auto pull behavior
       'deny', -- note that in our system require/request changes is built on top of these because request changes implies that the current identity under review would be rejected by that reviewer, so more a revise and resubmit situation, outright deny is for same reasons, out of scope, but since this is interlex that doesn't mean you are fundamentally excluded, you just have to figure out how to come to some agreement down the line
       'present', -- while some systems allow this vote we almost certinaly will not because it is completely useless for the kind of decisions we are making ... if you look at it and have no comments then either approve or deny it
       'absent'  -- this is what is put for true absenst, only approve, deny and present can be input
);

CREATE TYPE vote_outcome_types AS ENUM (
       'pass',
       'fail'
);

/*
CREATE TYPE pull_review_vote_allocation_types AS ENUM (
       -- not actually used, just here to help clarify the formalism
       'one-man-one-vote', -- want more votes? convince them
       'one-man-one-vote-with-delegation', -- can give your vote to someone else, accounting of such exchanges goes outside the system
       'votes-cast-using-some-currency', -- money (do not want)
       'pay-people-to-vote', 'reward-people-for-voting',
       'punish-people-for-voting', 'make-people-pay-to-vote',
       -- if you can exchange money for something else to get
       -- what you want, why use it to vote etc.
       -- 'one-man-as-many-votes-as-he-can-buy',
);

CREATE TYPE pull_review_vote_visibility_types AS ENUM (
       'public', -- this is the one that
       'private',
       'denyable', -- pretty sure this one is hard to engineering
);

*/

/*

really don't want this rabbit hole, but the reason this crops up is
because of abstain/present and absent votes which can lead to
deadlocks which is why you want to be able to study the systems in
advance

CREATE TYPE pull_review_sidedness_types AS ENUM (
       -- yet more complexity, that I think we really do not want to get into
       'can-pass-automatically-at-some-threshold', -- ignoring quorum ? or what ?
       'can-fail-automatically-at-some-threshold', -- ignoring quorum ? or what ?
);
*/

/*
really this is a survey of voting systems the axes are

reviewer-pool-size [0 n] (zero for auto)
quorum-size [0 m] m <= n (zero for auto, 1 for anybody, m for unanimity)
default-vote-type {approve deny abstain absent} how null votes are treated by default, this interacts with quorum and with the final result
# default-result {approve deny} (request extension) I think there is a clearer way to formalize this
time-limit {finite indefinite} the vote will remain open until someone takes an action
present-count [m n]
vote-type {agree, disagree, abstain} practically these become   {approve deny abstain} aka up/down/present where present needed to reach quorum
criteria
north-criteria {any-veto any-approve majority ratio-of-present ratio-of-reviewer-pool-size exact-minimum ...} (not fully orthogonoalized yet)
for sake of expediency the our defaults will be reviewer-pool-size n quorum-size 1 default-result

*/

/* better handled by voting_system
CREATE TYPE pull_review_pass_fail_criteria AS ENUM (
-- TODO intended to work cooperatively with approval arity 1 vs many and auto
'all', -- unanimous
'any', -- single
'majority',
-- 'exact', -- defaults to 1 -> any
-- 'majority',
-- 'ratio', -- 0.5 -> majority
);
*/

/*
perspectives do not need to specify this unless they
wish to override the default behavior as specified on
the root perspective

individual pull requests may select different review criteria
and different sets of reviewers, these tables provide the default
value set for that perspective (i.e. usually group)

for utility perspectives, e.g. tom's view of uberon the
default is approve because upstream maintainers need to be
able to make changes

... huh, searching for taxonomy of voting systems produces some ... interesting results these days it seems

note also that most of our review processes naturally have three phases, drafting, review, and maintainer sign off
maintainer sign off is pretty much always at least one, bdfl style etc. sometimes there are multiple steps, for us
however we don't want to pull a linux kernel and require our domain experts to have to maintain their own git repo
we just want them to look at the patches and thumbs up thumbs down, and then there's the maintainer can merge anyway etc.
*/
CREATE TABLE voting_systems(
       -- aka electoral_systems, voting_systems, decision_processes, etc.
       id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

       default_vote vote_types not null, -- if a vote is not cast how is it interpreted
       --duration interval, -- null -> indefinite

       -- XXX duration goes somewhere else, tigger conditions for the
       -- default vote can be more than just duration, they can be
       -- quorum is reached (default absent), etc.

       quorum_exact integer,
       quorum_ratio numeric check (0 <= quorum_ratio and quorum_ratio <= 1),
       check ((quorum_exact is     null and quorum_ratio is not null) or
              (quorum_exact is not null and quorum_ratio is     null)),

       -- pass_criteria pull_review_pass_fail_criteria,
       pass_exact integer,
       pass_ratio numeric check (0 <= pass_ratio and pass_ratio <= 1),
       check (((pass_exact is     null and pass_ratio is not null) or
               (pass_exact is not null and pass_ratio is     null)) or
              (fail_exact is not null or  fail_ratio is not null)),

       -- fail_criteria pull_review_pass_fail_criteria,
       fail_exact integer,
       fail_ratio numeric check (0 <= fail_ratio and fail_ratio <= 1),
       check (((fail_exact is     null and fail_ratio is not null) or
               (fail_exact is not null and fail_ratio is     null)) or
              (pass_exact is not null or  pass_ratio is not null)),
       description text, -- this table describes a finite space of voting systems, sometimes it is useful to have a description of the system to facilitate reuse (witness the examples below)
       CHECK ((description ~* '^\S+') AND (description ~* '\S+$')),
       UNIQUE NULLS NOT DISTINCT (default_vote, quorum_exact, quorum_ratio, pass_exact, pass_ratio, fail_exact, fail_ratio)
       --CHECK (default_vote != 'accept' OR duration is not null)
       /*
       examples

       process where an approve by any reviewer leads to pass
       --(default_vote, quorum_exact, pass_exact, fail_ratio) VALUES ('absent',  1, 1, 1) -- actually this is wrong because quorum_exact being 1 means that a single reviewer can also deny (which is not wrong, but doesn't match the meaning, which is that any one approval passes)
       --(default_vote, quorum_exact, pass_exact, fail_ratio) VALUES ('present', 1, 1, 1) -- still not quite right
       --(default_vote, quorum_exact, pass_exact            ) VALUES ('present', 1, 1   ) -- a more understandable version, fail_ratio is implicitly 1 because everyone must fail UGH still wrong
         (default_vote, quorum_ratio, pass_exact            ) VALUES ('present', 1, 1   ) -- here we are


       process where a deny by any reviewer leads to fail (aka process where pass requires all approve) (unanimous approval)
       --(default_vote, quorum_exact, pass_ratio, fail_exact) VALUES ('absent',  1, 1, 1) -- HRM this example shows that we need separate quorums because ratio could be of quorum or of total which is a bad way to model ... no wait ... i think i have specced this wrong
       --(default_vote, quorum_ratio,             fail_exact) VALUES ('present', 1,    1) -- there we go, we can do outstanding checks at every point, note that as specified this is somewhat useless because it also implies that everyone must eventually vote in order to pass
         (default_vote, quorum_ratio, pass_ratio            ) VALUES ('absent',  1, 1   ) -- this is that pass requires unanimous approve, it is perhaps an easier way to express that any review may deny, but has a definite outcome

       process that passes if reviewers do not respond within duration
       (default_vote, quorum_ratio, pass_ratio, duration) VALUES ('accept', 1, 1, make_interval(days=14))
       -- i think this is more or less the default desired process for review with duration, that is that any response other than doing nothing or explicit accept
       -- leads to fail which doesn't mean that the pull is closed, but rather that it goes back to draft and then the review process starts again, there we go yeah

       process that passes if a minority of reviewers do not respond
       (default_vote, quorum_ratio, pass_ratio, duration) VALUES ('accept', 1, 0.5, make_interval(days=14)) -- if 2 of 5 reviewers respond 'present' it will still pass, which is probably not a great process

       */
);

CREATE TYPE day_of_week AS ENUM (
'sunday',
'monday',
'tuesday',
'wednesday',
'thursday',
'friday',
'saturday'
);

/*
-- TODO another useful duration, which we do not implement here, is first day-of-week at end of day after duration, so if i create the
-- review on saturday then the reviewers effectively have 13 days but it means if their week is booked they can shuffle the next one
CREATE TYPE vote_trigger_type AS ENUM (
       -- FIXME don't use this
       'quorum',
       'duration',
       'day-after-duration'
);
*/

CREATE TYPE vote_visibility AS ENUM (
       -- TODO right now everything is public, but this also isn't properly factored because there are +three+ four sets of people, committee, submitter + from perspective, to perspective, and everyone else
       -- and visibilty at different points in time, during voting and after voting
       'public',
       'perspective',
       'reviwers',
       'reviewers-not-absent',
       'committee', -- anyone on the committee
       'committee-and-reviewers', -- allow current committe and historical reviewers
       'secret'
);

CREATE TYPE review_blinding AS ENUM (
       -- TODO right now everything is public, but there are many reasons to blind, and also have random review panels so we want the functionality
       -- this is also not properly factored for the same reasons as vote visibility
       'public',
       'everyone-anon',
       'from-perspective-anon', -- kind of hard to hide given that reviewers can always go find it, more the principle of the thing for people who want to do it right
       'committee-anon', -- committee members can see other members but the submitter cannot, and the committee can see who the submitter is (study section)
       'reviewers-anon' -- committee members cannot see who the others are but can see who the submitter is (paper review)
);

/*
oh man so many variables here ...
double blind review ... single blind review ...
*/

/*
CREATE TABLE perspective_default_pull_review_config(
       perspective_id integer PRIMARY KEY references perspectives (id),
       review_process_spec integer references review_process_specs (id),
       -- TODO where does visibility sit? right now everything is going to be public
);
*/

/*
i think this makes sense

|     | default | required  |
| yes | default | required  |
| no  | allowed | forbidden |

however we we actually want in the types
are forbidden, no, yes, required because no and yes are the default values and can be changed? sigh keep i with fadr
*/
CREATE TYPE pull_blinding_type AS ENUM (
       'forbidden', -- forbidden required no  always no
       'allowed',   -- allowed   default  no  starts no  can be yes
       'default',   -- allowed   default  yes starts yes can be no
       'required'  -- allowed   required yes always yes
);

CREATE TABLE review_process_specs(
       id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
       voting_system integer NOT NULL references voting_systems (id),
       allow_change_vote boolean DEFAULT TRUE,

       -- criteria for triggering the vote counting
       duration interval,
       CHECK (duration IS NULL OR duration > '0 secs'),
       duration_dow_after day_of_week, -- implemeting when voting for individuals ends tiggering a no-response and when all voting ends is put elsewhere since the ux for that is a whole field of study unto itself
       CHECK (duration_dow_after IS NULL OR (duration_dow_after IS NOT NULL AND duration IS NOT NULL)), -- always friday duration 0 secs
       quorum_reached interval, -- if quorum reached is not null then the value determines how long currently absent reviewers have to vote, quorum reached may be zero seconds, note that final signoff operates as if it were pass if any maintainer approve with quorum_reached '0 secs'

       pull_blinding pull_blinding_type DEFAULT 'allowed', -- someone can select it but if there is no review the pr immediately becomes
       review_blinding_pre review_blinding DEFAULT 'public',
       review_blinding_post review_blinding DEFAULT 'public',
       review_visibility_pre vote_visibility DEFAULT 'public',
       review_visibility_post vote_visibility DEFAULT 'public',
       description text NOT NULL, -- these are quite complicated, need a description for normal consumption, might never allow users to create their own
       CHECK ((description ~* '^\S+') AND (description ~* '\S+$')),

       UNIQUE NULLS NOT DISTINCT (
              voting_system, allow_change_vote, duration, duration_dow_after, quorum_reached,
              pull_blinding, review_blinding_pre, review_blinding_post, review_visibility_pre, review_visibility_post
               )
);

CREATE TABLE perspective_pull_settings(
       -- as with others, thse are not mandatory and only needed if the group needs to diverge from the defaults
       perspective integer PRIMARY KEY references perspectives (id),
       default_spec integer references review_process_specs (id),
       review_required boolean DEFAULT FALSE,
       allow_other_review_processes boolean DEFAULT TRUE
);

/* -- this is backward, pulls may have multiple repeated review processes
CREATE TABLE pull_review_process_spec(
       -- needed only to override the perspective default
       pull_id integer references pull_requests (id),
       review_process_spec integer references review_process_specs (id),
       primary key (pull_id, review_process_spec)
);
*/

CREATE TABLE review_processes(
       id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
       pull_id integer references pull_requests (id),
       spec integer references review_process_specs (id),
       committee integer references committees (id),
       -- committees can have one reviewer, it is ok, it is mainly a
       -- mechanism to determine who to send notifications to and to
       -- delimit who is eligible to vote, there is a bit of nuance
       -- here, which is whether reviewers only have to be eligible at
       -- the time they cast the vote or whether they must be
       -- eligible (i.e. actively on the review committee) when the
       -- tally is made, i think the answer is both, they must have
       -- been eldigible when they cast (trigger 1) and they must not
       -- have been removed at tally time, we are not going to worry
       -- about the nonsense that can be gotten up to around removing
       -- reviewers and whether the causes the review process to reset
       -- adding reviewers would not, removing reviewers probably
       -- should it simplifies the criteria, can be managed with an on
       -- delete tirgger on committee_reviewers and under systems where
       -- votes can be changed we just allow older votes ... point is
       -- there is tons of marginal complexity here that we aren't going
       -- to mess with right now
       start_datetime TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE review_quorum(
       review_process integer PRIMARY KEY references review_processes (id),
       quorum_datetime TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE review_outcomes(
       -- we do this as a separate table so that both are append  only
       review_process integer PRIMARY KEY references review_processes (id),
       tally_datetime TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
       -- outcome vote_outcome_types -- the outcome is boolean use a boolean
       -- outcome bool -- 1 pass 0 fail
       passed bool -- you can always go back and recount from the review counts table
);

CREATE TABLE review_process_votes(
       -- obviously this is all public, I'm not touching anything that needs to be hidden right now
       review_process integer references review_processes (id),
       -- FIXME TODO trigger to ensure that the reviewer is eligible at the time the vote is cast
       reviewer integer references users (id),
       -- multiple votes allowed, only the most recent is included in the tally
       -- if multiple votes are NOT allowed then will have a trigger
       vote_datetime TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
       primary key (review_process, reviewer, vote_datetime),
       vote vote_types -- we record absents
);


CREATE FUNCTION dayOfWeekEndOfDayAfter(dayow day_of_week, after_datetime TIMESTAMP WITH TIME ZONE) RETURNS TIMESTAMP WITH TIME ZONE AS $$
DECLARE
after_day integer;
target_day integer;
BEGIN
select extract(dow from after_datetime) into after_day; -- 0 == sunday
select n into target_day from (select unnest as d, row_number() over () - 1 as n from (select unnest(enum_range(NULL::day_of_week)))) where d = dayow;
return date_trunc('day', after_datetime) + make_interval(days := (((7 + (target_day - after_day)) % 7) + 1), secs := -1);
END;
$$ language plpgsql;

CREATE FUNCTION reviewCloseDatetime(review_process integer) RETURNS TIMESTAMP WITH TIME ZONE AS $$
DECLARE
start_dt timestamp with time zone;
dur interval;
dow day_of_week;
BEGIN
    select rp.start_datetime, rps.duration, rps.duration_dow_after into start_dt, dur, dow
    from review_processes as rp
    join review_process_specs as rps on rp.spec = rps.id
    where rp.id = review_process;

    if (dur is null) then
        return null;
    elsif (dow is null) then
        return start_dt + dur;
    else
        return dayOfWeekEndOfDayAfter(dow, start_dt + dur);
    end if;
END;
$$ language plpgsql;

CREATE FUNCTION reviewClosed(review_process integer) RETURNS bool AS $$
BEGIN
    return CURRENT_TIMESTAMP > reviewClosedDatetime(review_process);
END;
$$ language plpgsql;

CREATE FUNCTION vote_eligible() RETURNS trigger AS $$
BEGIN
    IF NOT EXISTS (
       SELECT *
       FROM review_processes AS rp
       JOIN comittee_reviewers AS cr ON cr.committee = rp.committee
       WHERE NEW.review_process = rp.id AND NEW.reviewer = cr.reviewer) THEN
             RAISE EXCEPTION 'reviewer % not a current member of committee %',
                   (SELECT groupname FROM groups as g WHERE g.id = NEW.reviewer),
                   (SELECT name FROM committees AS c WHERE c = NEW.committee);
    ELSIF (EXISTS (SELECT * FROM review_process_votes AS rpv WHERE rpv.review_process = NEW.review_process AND rpv.reviewer = NEW.reviewer) AND
           EXISTS (SELECT * FROM review_processes AS rp
                   JOIN review_process_specs AS rps ON rp.spec = rps.id AND NOT rps.allow_change_vote
           WHERE NEW.review_process = rp.id)) THEN
                 RAISE EXCEPTION '% already voted at %',
                       (SELECT groupname FROM groups as g WHERE g.id = NEW.reviewer),
                       (SELECT vote_datetime FROM review_process_votes AS rpv
                        WHERE rpv.review_process = NEW.review_process AND rpv.reviewer = NEW.reviewer);
    ELSIF reviewClosed(NEW.review_process) THEN
          RAISE EXCEPTION 'voting closed as of %', reviewCloseDatetime(NEW.review_process);
    ELSE
        RETURN NEW;
    END IF;
END;
$$ language plpgsql;

CREATE FUNCTION tallyVotes(this_review_process integer) RETURNS bool AS $$
DECLARE
pe integer;
pr numeric;
fe integer;
fr numeric;
pass_n numeric;
fail_n numeric;

qtotal integer;
approves integer;
denies integer;
presents integer;
absents integer;

pass bool;
fail bool;
BEGIN
    -- TODO this is a bit more complicated because we have to select only the latest votes for each reviewer
    -- and we also have to follow the voting system
    SELECT vs.pass_exact, vs.pass_ratio, vs.fail_exact, vs.fail_ratio INTO pe, pr, fe, fr
    from review_processes as rp
    join review_process_specs as rps on rp.spec = rps.id
    join voting_systems as vs on rps.voting_system = vs.id
    where rp.id = this_review_process;

    IF (pr is not null) THEN
       pass_n := pr * qtotal;
    ELSIF (pe is not null) THEN
       pass_n := pe;
    END IF;

    IF (fr is not null) THEN
       fail_n := fr * qtotal;
    ELSIF (pe is not null) THEN
       fail_n := fe;
    END IF;

    -- TODO sanity check here in addition to in trigger/constraints on voting systems?

    with final_votes as (
        select * from review_process_votes as rpv where rpv.review_process = this_review_process -- TODO FIXME XXX must remove non latest
    ), _tot as (select count(*) from final_votes as fv where fv.vote != 'absent'
    ), _apr as (select count(*) from final_votes as fv where fv.vote = 'approve'
    ), _den as (select count(*) from final_votes as fv where fv.vote = 'deny'
    ), _pre as (select count(*) from final_votes as fv where fv.vote = 'present')
    select _tot.count, _apr.count, _den.count, _pre.count, count(*)
    into qtotal, approves, denies, presents, absents
    from final_votes as fv where fv.vote = 'absent';

    IF (pass_n is not null) THEN
       IF (pr is null) then
          pass := approves >= pass_n; -- exact means >=
       else
          pass := approves > pass_n; -- ratio means strictly greater FIXME TODO review this 10 reviewers 0.5 5 is not majority ... so strictly greater
       end if;
    END IF;
    IF (fail_n is not null) THEN
       if (fr is null) then
         fail := denies >= fail_n;
       else
         fail := denies > fail_n;
       end if;
    END IF;

    -- without thinking too hard about this, fail takes priority over pass, but that should probably be configurable
    return pass and not fail;
END;
$$ language plpgsql;

CREATE FUNCTION process_review_votes() RETURNS trigger AS $$
DECLARE
present integer;
csize integer;
reached integer;
qr numeric;
qe integer;
current_committee integer;
quorum_dt TIMESTAMP WITH TIME ZONE;
can_tally bool;
BEGIN
-- if the default vote is anything other than absent then i think there has to be a duration? no, not true
-- present also works without duration because quorum will be reached immediately, but there is not enough
-- information to determine whether the review will fail or pass until either one reviewer approves
-- a review will simply wait until

-- check for quorum
-- select reviewCloseTime;
select rp.committee,      rps.quorum_reached, vs.quorum_ratio, vs.quorum_exact
  INTO current_committee, reached,            qr,              qe
from review_processes as rp
join review_process_specs as rps on rp.spec = rps.id
join voting_systems as vs on rps.voting_system = vs.id
where rp.id = NEW.review_process;

select count(*) INTO csize FROM committee_reviewers as cr where cr.committee = current_committee;
select count(*) INTO present FROM (SELECT DISTINCT reviewer FROM review_process_votes AS rpv WHERE rpv.review_process = NEW.review_process);
select quorum_datetime into quorum_dt from review_quorum where review_quorum.review_process = NEW.review_process;

IF ((qr is null and present >= qe) or (present > csize * qr)) AND quorum_dt IS NULL THEN-- >= for exact, > for ratio
   -- quorum achieved
   with rq as (INSERT INTO review_quorum (review_process) VALUES (NEW.review_process) RETURNING quorum_datetime)
   select rq.quorum_datetime into quorum_dt;
END IF;

can_tally := TRUE; -- FIXME TODO

IF (quorum_dt is not null) AND can_tally THEN
   INSERT INTO review_outcomes (review_process, outcome) VALUES (NEW.review_process, tallyVotes(NEW.review_process));
END IF;

RETURN NULL;
END;
$$ language plpgsql;

CREATE TRIGGER review_process_vote_eligible BEFORE INSERT ON review_process_votes FOR EACH ROW EXECUTE PROCEDURE vote_eligible();
CREATE TRIGGER process_review_votes AFTER INSERT ON review_process_votes FOR EACH ROW EXECUTE PROCEDURE process_review_votes();


CREATE TABLE committee_reviewers(
/*
TODO streamline onboarding for reviewers, e.g.

you have be requested/reccomended as a domain expert reviewer for ... by your colleague whosy whatsit
you can accept by following link below to log into or register for interlex
https://uri.interlex.org/u/ops/reviewer-new?email={email}?committee={committee}
or maybe
https://uri.interlex/org/{group}/priv/reviewer-new?reviewer-token={token}
only consumed once they log in or sign up and we have the redirect

NOTE ideally the workflow for this will be to search for reviewers inside interlex and just request
that they review, orcid, email, name, though we don't have that anywhere on the radar, except that
they may show up in the elasticsearch index because their orcids will be indexed ... HRM

we can't automatically send emails to people asking them to sign up to be a reviewer because that
can be abused by spammers, so a generated form is the best we can do

instead, in the short run we can have a template that can be generated for someone putting together
a review committee similar to the one above

*/
       committee integer references committees (id),
       reviewer integer references users (id)
);

CREATE TABLE perspective_default_committee(
       perspective integer references perspectives (id),
       committee integer references committees (id),
       primary key (perspective, committee)
);
