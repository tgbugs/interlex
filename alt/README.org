# -*- org-babel-tangle-use-relative-file-links: t -*-
#+TITLE: InterLex alternate resolver setup
#+OPTIONS: num:nil

InterLex =alt= is a reduced set of the InterLex codebase for serving
directly from the mysql database. The necessary subset of the code
that is needed is copied into this directory and installed from the
main interlex source.

* Using this file :noexport:
:PROPERTIES:
:VISIBILITY: folded
:END:
You can either [[https://orgmode.org/manual/Extracting-Source-Code.html][tangle]]
this file in emacs using =C-c C-v t= or you can tangle
the whole file from the command line using with the following.
#+name: tangle-this-file
#+header: :tangle ./bin/tangle-readme
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :eval never :results none :noweb yes
<<&alt-path>>
THIS_FILE=${ALT_PATH}/README.org
emacs --batch \
      --quick \
      --load ~/git/orgstrap/init.el \
      --load org \
      --load ob-shell \
      --eval "(org-babel-tangle-file \"${THIS_FILE}\")"
#+end_src
The core functionality is tangled to files in [[file:./bin/]].
You should also run =shellcheck= on the tangled files if you make any changes.
* Setup
:PROPERTIES:
:CUSTOM_ID: setup
:END:
** Install wheel on build machine
The build machine will work with any version of python, however it that
version does need to have =wheel= installed e.g. via =pip install wheel=.
** Install python on server
Install =python3.7-devel= (or greater), =pip=, and =pipenv= on the server that
will run InterLex Alt. For example on CentOS

#+begin_src bash
sudo yum install python37-devel python37-pip
sudo pip install pipenv
#+end_src
** Set environment variables
Set =INTERLEX_DEPLOY_USER=, =INTERLEX_USER=, and =INTERLEX_SERVER=
environment variables.  The =INTERLEX_DEPLOY_USER= should have =sudo=
access, =INTERLEX_USER= should NOT have =sudo= or =wheel= access.
** Build and deploy code and config
Get the absolute path to the script and use it to find the alt folder.
#+name: &alt-path
#+begin_src bash
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve all symlinks
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # resolve relative symlinks
done
ABS_PATH="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

ALT_PATH="${ABS_PATH}/../"
#+end_src

Go to the alt folder and clean out any existing build files.
#+name: &pushd-clean
#+begin_src bash
pushd ${ALT_PATH} &&
git clean -dfx &&  # cleans only the alt subdir
git checkout HEAD -- resources/filesystem/  # prevent stale user
#+end_src

Build python wheels and package them for deployment.
#+name: &build-alt-zip
#+begin_src bash
python setup.py bdist_wheel --universal &&
python setup.py clean --all &&
rm -rf *.egg-info &&
mv dist/* run/ &&
rmdir dist &&
#pipenv install  # leave this out for now due to gunicorn detection issues
rm alt.zip;
zip -r alt.zip README.org &&
zip -r alt.zip run/ &&
#+end_src

# FIXME can't assume that INTERLEX_USER and INTERLEX_RUNTIME_USER are the same (sigh)
# FIXME look at scigraph deploy for the right way to do this ?? no that doesn't quite
# work because I hack around the permissioning issue by having two separate ssh
# connections, which makes the code clearer on the one hand but the connections more
# complex on the other (sigh)
Deploy the build artifact to the server.
#+name: &scp-zip
#+begin_src bash
rsync --archive --verbose alt.zip ${INTERLEX_DEPLOY_USER}@${INTERLEX_SERVER}:${TEAMPTARGET}
popd || exit 1
#+end_src

The first time InterLex Alt is set up on a server run [[file:./bin/config-build.sh]].
#+name: config-build.sh
#+header: :shebang "#!/usr/bin/env bash"
#+header: :noweb no-export
#+header: :tangle-mode (identity #o755)
#+begin_src bash :tangle ./bin/config-build.sh :comments noweb
<<&alt-path>>
<<&pushd-clean>>
grep -rl interlex resources/filesystem/ | xargs sed -i "s/{:interlex-user}/${INTERLEX_USER}/g" &&
<<&build-alt-zip>>
zip -r alt.zip resources/filesystem/  # first time only add deploy files
<<&scp-zip>>
#+end_src

Subsequently run [[file:./bin/build.sh]].
#+name: build.sh
#+header: :shebang "#!/usr/bin/env bash"
#+header: :noweb no-export
#+header: :tangle-mode (identity #o755)
#+begin_src bash :tangle ./bin/build.sh :comments noweb
<<&alt-path>>
<<&pushd-clean>>
<<&build-alt-zip>>
<<&scp-zip>>
#+end_src
** Remote commands
After deploying the files to the server run the following remote
commands on =INTERLEX_SERVER=. NOTE: Make sure you create a
=~/.mypass= file that conforms to the syntax of =~/.pgpass= i.e.
each line should look like =server.url.org:port:dbname:user:password=
and should have read write permission only for your user (=chmod 0600=).
If you do not a warning will appear and the server will not start.

The first time run [[file:./bin/config-remote.sh]].
#+name: &config-remote-command
#+begin_src bash :noweb yes
# TODO interlex user account creation
if [ ! -d /var/lib/ilxalt ]; then
    sudo mkdir /var/lib/ilxalt
fi
pushd /var/lib/ilxalt  # FIXME SIGH
rm -rf run/
rm -rf resources/filesystem/
unzip -o alt.zip || exit 1
sudo /bin/cp -f resources/filesystem/etc/systemd/system/ilxalt.service /etc/systemd/system/ || exit 2
sudo /bin/cp -f resources/filesystem/etc/systemd/system/ilxalt.socket /etc/systemd/system/ || exit 3
sudo /bin/cp -f resources/filesystem/etc/tmpfiles.d/ilxalt.conf /etc/tmpfiles.d/ || exit 4
sudo /bin/cp -f resources/filesystem/etc/nginx/sites-available/uri.interlex.org.conf /etc/nginx/sites-available/ || exit 5  # carful here
sudo unlink /etc/nginx/sites-enabled/uri.interlex.org.conf
sudo ln -s /etc/nginx/sites-available/uri.interlex.org.conf /etc/nginx/sites-enabled/uri.interlex.org.conf || exit 6
sudo systemd-tmpfiles --create || exit 7
sudo systemctl daemon-reload || exit 8
sudo systemctl enable ilxalt || exit 9
pushd run  || exit 10
pipenv --rm  # the very first time this can fail
pipenv install || exit 11
popd || exit 12
touch .mypass || exit 13
chmod 0600 .mypass || exit 14
if [ ! -s .mypass ]; then
    echo ~/.mypass has no records
    exit 15
fi
<<&restart-ilxalt>>
sudo systemctl restart nginx
#+end_src

#+name: &restart-ilxalt
#+begin_src bash
sudo systemctl restart ilxalt &&
    sleep 5
sudo systemctl is-active --quiet ilxalt
if [ $? -ne 0 ]; then
    sudo journalctl -u ilxalt.service -n 50
    exit 100;
fi
#+end_src

#+name: config-remote.sh
#+header: :shebang "#!/usr/bin/env bash" :noweb no-export :tangle-mode (identity #o755)
#+begin_src bash :tangle ./bin/config-remote.sh :comments noweb
ssh ${INTERLEX_DEPLOY_USER}@${INTERLEX_SERVER} "
<<&config-remote-command>>
"
SSH_EXIT=$?
if [ $SSH_EXIT -eq 15 ]; then
    echo you need to edit ~/.mypass on ${INTERLEX_SERVER} as ${INTERLEX_USER} to complete setup
    echo the pattern used to set the password is deocumented in step five of README.org on the server
    exit $SSH_EXIT
elif [ $SSH_EXIT -ne 0 ]; then
    echo remote command failed with $SSH_EXIT
    exit $SSH_EXIT
fi
#+end_src

Subsequently run [[file:./bin/remote.sh]].
#+name: &remote-command
#+begin_src bash :noweb yes
pushd /var/lib/ilxalt  # FIXME SIGH
mv -f run/*.whl .
rm run/Pipenv.lock
unzip -o alt.zip || exit 1
cd run || exit 2
pipenv --rm
pipenv install *.whl || exit 3
<<&restart-ilx>>
#+end_src

#+name: remote.sh
#+header: :shebang "#!/usr/bin/env bash" :noweb no-export :tangle-mode (identity #o755)
#+begin_src bash :tangle ./bin/remote.sh :comments noweb
ssh ${INTERLEX_DEPLOY_USER}@${INTERLEX_SERVER} "
<<&remote-command>>
"
SSH_EXIT=$?
if [ $SSH_EXIT -ne 0 ]; then
    exit $SSH_EXIT
fi
#+end_src

* Testing
:PROPERTIES:
:CUSTOM_ID: testing
:END:
On a redeploy, the easiest way to test whether everything is working is
to change TestRoutes.host in =test/test_alt.py= to match the test server
and then run =python -m unittest test/test_alt.py=. TODO add this to the
deploy scripts for the test server? Simple testing
#+begin_src bash
TEST_HOST=test.host; curl --header 'Host: uri.interlex.org' http://${TEST_HOST}/base/ilx_0109470.ttl
TEST_HOST=test.host; curl --header 'Host: uri.interlex.org' http://${TEST_HOST}/sparc/ontologies/community-terms.ttl
#+end_src
